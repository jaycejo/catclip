#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# catclip - Context Gatherer for LLMs
#
# Copies code files to clipboard with "# File: path" headers for AI prompts.
# Filters secrets, binaries, and build artifacts by default.
#
# DESIGN PHILOSOPHY:
# 1. Safety First: Don't leak secrets (.env) or junk (node_modules) by default.
# 2. Native Dependencies: Use standard tools (awk, find, git) to avoid npm/pip.
# 3. Git-Aware: Use 'git ls-files' as source of truth when in a repo.
# 4. Self-Healing: Embedded defaults restore config if missing/broken.
# 5. Speed: Extension checks before 'file' command, batch operations.
# 6. Bash 3.2: macOS ships old bash; avoid associative arrays, mapfile, |&.
# ------------------------------------------------------------------------------

# SAFETY BOILERPLATE
# set -e: Exit on command failure (fail-fast).
# set -u: Error on unset variables (prevents rm -rf / bugs).
# set -o pipefail: Fail if any pipeline command fails.
set -euo pipefail

# IFS: Only split on newline/tab, not space. Preserves filenames with spaces.
IFS=$'\n\t'

# 0) TERMINAL CONFIGURATION
# Force 256-color mode for consistent output in restricted shells.
export TERM="${TERM:-xterm-256color}"

# 1) PREREQUISITE CHECKS
# Fail fast if essential tools are missing.
for cmd in pbcopy find mktemp awk stat git file; do
  if ! command -v "$cmd" &>/dev/null; then
    echo "Error: '$cmd' is required but not found in PATH." >&2
    exit 1
  fi
done

# 2) COLORS & THEME
# ANSI escape codes. Semantic naming (CLR_ERROR vs RED) for self-documenting code.
RESET=$'\033[0m'
BOLD=$'\033[1m'
DIM=$'\033[2m'
CYAN=$'\033[36m'
GREEN=$'\033[32m'
YELLOW=$'\033[33m'
RED=$'\033[31m'

# Semantic aliases for themed output
CLR_SUCCESS=$'\033[32m'
CLR_ERROR=$'\033[31m'
CLR_WARN=$'\033[33m'
CLR_DIR=$'\033[1;34m'
CLR_LABEL=$'\033[90m'
CLR_VALUE=$'\033[1m'
CLR_TREE=$'\033[90m'
CLR_PROMPT=$'\033[36m'
CLR_GIT=$'\033[35m'

# 3) CONFIGURATION MANAGEMENT
# XDG Base Directory spec: ~/.config/catclip/ignore.yaml
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/catclip"
CONFIG="$CONFIG_DIR/ignore.yaml"

# EMBEDDED DEFAULTS (The "Factory Reset" State)

get_default_config() {
  cat <<'EOF'
ignore_dirs:
  # Version Control
  - .git
  - .svn
  - .hg
  
  # IDEs & Editors
  - .idea
  - .vscode
  - .cursor
  - .history
  
  # JavaScript / Node
  - node_modules
  - bower_components
  - jspm_packages
  - coverage
  - .npm
  - .yarn
  - .pnpm-store
  
  # Python
  - __pycache__
  - venv
  - .venv
  - env
  - .pytest_cache
  - .mypy_cache
  - .tox
  - htmlcov
  
  # Java / Build
  - target
  - build
  - dist
  - out
  - bin
  - obj
  - .gradle
  
  # Web Frameworks
  - .next
  - .nuxt
  - .serverless
  - .turbo
  
  # Test directories
  - test
  - tests
  - __tests__
  - fixtures
  - __fixtures__

ignore_files:
  # System
  - .DS_Store
  - .AppleDouble
  - .LSOverride

  # Binaries & Archives
  - "*.class"
  - "*.pyc"
  - "*.pyo"
  - "*.exe"
  - "*.dll"
  - "*.so"
  - "*.dylib"
  - "*.jar"
  - "*.war"
  - "*.zip"
  - "*.tar.gz"
  - "*.db"
  - "*.sqlite"
  
  # Media
  - "*.png"
  - "*.jpg"
  - "*.jpeg"
  - "*.gif"
  - "*.ico"
  - "*.svg"
  - "*.pdf"
  - "*.mov"
  - "*.mp4"
  - "*.webm"

  # Lockfiles
  - package-lock.json
  - yarn.lock
  - pnpm-lock.yaml
  - poetry.lock
  - Pipfile.lock
  - bun.lockb
  
  # Secrets (CRITICAL)
  - .env
  - .env.local
  - .env.*
  - "*.pem"
  - "*.key"
  - id_rsa
  - application.properties
  - application.yml

  # Logs
  - "*.log"
  - "*.tmp"
  - "*.bak"
  - "*.swp"
EOF
}

if [[ ! -f "$CONFIG" ]]; then
  mkdir -p "$CONFIG_DIR"
  get_default_config > "$CONFIG"
fi

# 4) CLEANUP TRAPS
TMPFILE=""
LISTFILE=""
UTF16_LIST=""
cleanup() {
  [[ -n "$TMPFILE" && -f "$TMPFILE" ]] && rm -f "$TMPFILE"
  [[ -n "$LISTFILE" && -f "$LISTFILE" ]] && rm -f "$LISTFILE"
  [[ -n "$UTF16_LIST" && -f "$UTF16_LIST" ]] && rm -f "$UTF16_LIST"
}
trap cleanup EXIT

# 5) HELPER FUNCTIONS

format_size() {
  awk -v b="$1" 'BEGIN {
    split("B KB MB GB TB", units);
    u=1;
    while(b >= 1024 && u < 5) { b/=1024; u++ }
    printf "%.2f%s", b, units[u]
  }'
}

print_tree() {
  local list_file="$1"
  sort "$list_file" | awk -v dir_col="$CLR_DIR" -v reset="$RESET" -v tree_col="$CLR_TREE" -F/ '
  {
    for (i=1; i<NF; i++) {
      if ($i != last[i]) {
        for (j=1; j<i; j++) printf tree_col "│   " reset
        if (i == 1) printf "" 
        else printf tree_col "├── " reset
        print dir_col $i "/" reset
        last[i] = $i
        for (k=i+1; k<=20; k++) delete last[k]
      }
    }
    for (j=1; j<NF; j++) printf tree_col "│   " reset
    printf tree_col "├── " reset
    print $NF
    delete last[NF]
  }'
}

print_help() {
  cat <<EOF
${BOLD}catclip${RESET} - Copy code context for AI prompts

  Recursively copies code files to your clipboard with a visual tree preview.
  Automatically filters out secrets, binaries, and build artifacts.
  Respects ${BOLD}.gitignore${RESET} and your ${BOLD}ignore list${RESET}.

${BOLD}Output Format:${RESET}
  Each file is prefixed with ${DIM}# File: path/to/file${RESET} so AI can see the structure.

${BOLD}Usage:${RESET}
  catclip [OPTIONS] [TARGETS...]

${BOLD}Targets:${RESET}
  ${BOLD}Fuzzy Directory Search:${RESET}
    ${CLR_SUCCESS}catclip repository${RESET}              # Finds any directory matching *repository*
    ${CLR_SUCCESS}catclip utils${RESET}                   # Finds src/utils, lib/utils, etc. (prompts if multiple)
  
  ${BOLD}Chained Path Resolution:${RESET}
    ${CLR_SUCCESS}catclip repository/domain/Model.java${RESET}  # Resolves 'repository' → 'domain' → copies 'Model.java'
    ${CLR_SUCCESS}catclip service/utils${RESET}                 # Resolves 'service' → 'utils' → copies directory contents

  ${BOLD}Full Relative Paths:${RESET}
    ${CLR_SUCCESS}catclip src/main/java/com/app/Model.java${RESET}    # Must exist from current directory
    ${CLR_SUCCESS}catclip .github/workflows/ci.yml${RESET}            # Dotted paths work
  
  ${BOLD}Files in Current Directory:${RESET}
    ${CLR_SUCCESS}catclip Dockerfile${RESET}              # File in current working directory
    ${CLR_SUCCESS}catclip pom.xml README.md${RESET}       # Multiple files
  
  ${BOLD}Mixed Arguments:${RESET}
    ${CLR_SUCCESS}catclip src repository/Model.java controller/UserController.java${RESET}
    # → Copies entire 'src' dir + 2 specific files

${BOLD}Options:${RESET}
  ${CLR_SUCCESS}--help, -h${RESET}
      Show this help message.

  ${CLR_SUCCESS}--no-ignore${RESET}
      ${BOLD}Temporarily${RESET} bypass all ignore rules for this copy only.
      
      ${DIM}catclip --no-ignore dist${RESET}
      ${DIM}catclip --no-ignore .env.local${RESET}

  ${CLR_SUCCESS}--yes, -y${RESET}
      Skip confirmation prompt (useful for large copies or scripts).

  ${CLR_SUCCESS}--print${RESET}
      Print to terminal in addition to copying to clipboard.

  ${CLR_SUCCESS}--list-ignores${RESET}
      Show what files and directories are currently being ignored.

  ${CLR_SUCCESS}--ignore [OPERATIONS]${RESET}
      Permanently modify your ignore list.
      
      ${BOLD}Add/remove files:${RESET}  +'pattern'  -'pattern'
      ${BOLD}Add/remove dirs:${RESET}   d+dirname  d-dirname
  
  ${CLR_SUCCESS}--reset-config${RESET}
      Restore the configuration file to factory defaults.

${CLR_ERROR}Not Allowed:${RESET}
  catclip ../config                              # Cannot go above working directory

${BOLD}Config Location:${RESET}
  ${DIM}$CONFIG${RESET}
EOF
}

# ------------------------------------------------------------------------------
# OPTIMIZED BINARY DETECTION
# ------------------------------------------------------------------------------
# Strategy: Check extensions first (fast), only use 'file --mime' as fallback.
# This avoids spawning a subprocess for every file. 10x faster on large repos.
is_text_file() {
  local f="$1"
  local ext="${f##*.}"
  
  case "$ext" in
    png|jpg|jpeg|gif|bmp|ico|svg|webp|pdf|\
    zip|tar|gz|bz2|xz|7z|rar|dmg|iso|\
    exe|dll|so|dylib|a|lib|o|obj|class|jar|war|ear|\
    pyc|pyo|pyd|wasm|\
    mp3|mp4|mov|avi|mkv|webm|flv|wmv|m4a|wav|flac|\
    ttf|otf|woff|woff2|eot|\
    db|sqlite|sqlite3)
      return 1
      ;;
  esac
  
  case "$ext" in
    txt|md|markdown|json|yaml|yml|xml|html|htm|css|scss|sass|less|\
    js|jsx|mjs|cjs|ts|tsx|mts|cts|\
    py|pyw|pyi|rb|java|php|sh|bash|zsh|fish|sql|\
    c|cc|cpp|cxx|h|hh|hpp|hxx|\
    go|rs|swift|kt|kts|scala|cs|fs|vb|vbs|\
    gd|godot|shader|unity|\
    makefile|Makefile|mk|cmake|gradle|jenkinsfile|Jenkinsfile|\
    dockerfile|Dockerfile|groovy|gvy|tf|hcl|toml|ini|cfg|conf|properties|\
    sln|csproj|vbproj|\
    r|R|clj|cljs|ex|exs|erl|hrl|elm|nim|zig|v|d|m|mm|\
    hs|lhs|jl|cl|lisp|rkt|\
    csv|tsv|patch|diff|lock|\
    graphql|gql|proto|sol|ps1|psm1|psd1|bat|cmd|asm|s|\
    vim|lua|pl|pm|dart|vue|svelte|astro|\
    rst|adoc|tex|j2|ejs|hbs|mustache|liquid)
      return 0
      ;;
  esac
  
  local mime
  mime=$(file -b --mime "$f" 2>/dev/null)
  
  [[ "$mime" =~ utf-16 ]] && return 1
  [[ "$mime" =~ utf-32 ]] && return 1
  [[ "$mime" =~ binary ]] && return 1
  
  [[ "$mime" == text/* ]] && return 0
  [[ "$mime" =~ application/json ]] && return 0
  [[ "$mime" =~ application/xml ]] && return 0
  [[ "$mime" =~ application/javascript ]] && return 0
  [[ "$mime" =~ application/x-sh ]] && return 0
  [[ "$mime" =~ application/x-yaml ]] && return 0
  
  [[ ! -s "$f" ]] && return 0
  
  return 1
}

# ------------------------------------------------------------------------------
# PATH RESOLUTION HELPERS
# ------------------------------------------------------------------------------

# SECURITY: Block parent traversal (../) to prevent copying outside project.
contains_parent_traversal() {
  local path="$1"
  [[ "$path" == *../* || "$path" == ../* || "$path" == *.. ]]
}

has_slashes() {
  [[ "$1" == */* ]]
}

# Fuzzy search for directories matching *pattern* anywhere in the tree.
# Optional base_dir scopes the search. Uses indexed arrays for Bash 3.2 compat.
fuzzy_search_dir() {
  local search_name="$1"
  local base_dir="${2:-.}"  # Default to current directory if not specified
  local found=()
  
  local search_prune_opts=()
  if [[ "$NO_IGNORE" == false ]] && (( ${#ignore_dirs[@]} > 0 )); then
    for d in "${ignore_dirs[@]}"; do 
      search_prune_opts+=( -name "$d" -prune -o )
    done
  fi

  local find_cmd_opts=()
  if (( ${#search_prune_opts[@]} > 0 )); then
    find_cmd_opts=( "${search_prune_opts[@]}" )
  fi
  find_cmd_opts+=( -type d -name "*${search_name}*" -print0 )

  while IFS= read -r -d '' d; do 
    if [[ "$IS_GIT" == true && "$NO_IGNORE" == false ]]; then
      if git check-ignore -q "$d" 2>/dev/null; then 
        continue
      fi
    fi
    found+=( "$d" )
  done < <(find "$base_dir" "${find_cmd_opts[@]}" 2>/dev/null)
  
  if (( ${#found[@]} == 0 )); then
    return 1
  elif (( ${#found[@]} == 1 )); then
    echo "${found[0]}"
    return 0
  else
    local context_msg="'$search_name'"
    [[ "$base_dir" != "." ]] && context_msg="'$search_name' in ${CLR_DIR}$base_dir${RESET}"
    printf "%s\n" "${BOLD}Multiple matches for $context_msg:${RESET}" >&2
    for i in "${!found[@]}"; do 
      printf "  ${BOLD}%2d)${RESET} ${CLR_DIR}%s${RESET}\n" $((i+1)) "${found[i]}" >&2
    done
    read -rp "Choose [1-${#found[@]}]: " c
    if [[ "$c" =~ ^[0-9]+$ ]] && (( c >= 1 && c <= ${#found[@]} )); then
      echo "${found[c-1]}"
      return 0
    else
      printf "%s\n" "${CLR_ERROR}Invalid selection.${RESET}" >&2
      exit 1
    fi
  fi
}

# Resolve a chained path like "accessibility/browser/file.ts"
# Returns the resolved directory path (without filename)
# Usage: resolve_chained_path "dir1/dir2/dir3" -> resolved_path
resolve_chained_path() {
  local path_segments="$1"
  local current_base="."
  local segments=()
  
  # Split path by /
  IFS='/' read -ra segments <<< "$path_segments"
  
  for segment in "${segments[@]}"; do
    # First check if exact subdirectory exists
    if [[ -d "$current_base/$segment" ]]; then
      current_base="$current_base/$segment"
    else
      # Fuzzy search within current base (using unified function with base_dir)
      if resolved=$(fuzzy_search_dir "$segment" "$current_base"); then
        current_base="$resolved"
      else
        printf "%s\n" "${CLR_ERROR}Error: No directory matching '$segment' found in $current_base${RESET}" >&2
        return 1
      fi
    fi
  done
  
  echo "$current_base"
  return 0
}

check_file_ignore() {
  local filename="$1"
  
  if [[ "$NO_IGNORE" == true ]]; then
    return 1
  fi
  
  for pat in "${ignore_files[@]:-}"; do
    if [[ "$filename" == $pat ]]; then
      return 0
    fi
  done
  
  return 1
}

# ------------------------------------------------------------------------------
# IGNORE CHECKING
# ------------------------------------------------------------------------------
# Two ignore sources: YAML config (global) + .gitignore (project-specific).
# IGNORE_REASON tracks which source matched, for better error messages.

# Returns 0 if ignored, 1 if allowed. Sets IGNORE_REASON to "yaml" or "gitignore".
is_dir_ignored() {
  local dirpath="$1"
  local dirname
  dirname=$(basename "$dirpath")
  IGNORE_REASON=""
  
  if [[ "$NO_IGNORE" == true ]]; then
    return 1
  fi
  
  # Check YAML config first
  if (( ${#ignore_dirs[@]} > 0 )); then
    for d in "${ignore_dirs[@]}"; do
      if [[ "$dirname" == "$d" ]]; then
        IGNORE_REASON="yaml"
        return 0
      fi
    done
  fi
  
  # Check git ignore if in git repo
  if [[ "$IS_GIT" == true ]]; then
    if git check-ignore -q "$dirpath" 2>/dev/null; then
      IGNORE_REASON="gitignore"
      return 0
    fi
  fi
  
  return 1
}

# Print standardized "directory is ignored" error/warning message
# Usage: print_dir_ignore_msg <dir_name> ["error"|"warning"]
print_dir_ignore_msg() {
  local dir_name="$1"
  local msg_type="${2:-error}"
  
  local prefix action suffix
  if [[ "$msg_type" == "warning" ]]; then
    prefix="${CLR_WARN}Warning:"
    action="but proceeding with explicit path."
  else
    prefix="${CLR_ERROR}Error:"
    action=""
    suffix="\n${DIM}Use --no-ignore to include it anyway.${RESET}"
  fi
  
  if [[ "$IGNORE_REASON" == "yaml" ]]; then
    printf "%s Directory '%s' is in ignore list%s${RESET}" "$prefix" "$dir_name" "${action:+, $action}" >&2
  else
    printf "%s Directory '%s' is ignored by .gitignore%s${RESET}" "$prefix" "$dir_name" "${action:+, $action}" >&2
  fi
  echo >&2
  
  [[ "$msg_type" == "error" ]] && printf "${DIM}Use --no-ignore to include it anyway.${RESET}\n" >&2
}

extract_dir_components() {
  local path="$1"
  local dir_part="${path%/*}"
  
  if [[ "$dir_part" == "$path" ]]; then
    return
  fi
  
  IFS='/' read -ra components <<< "$dir_part"
  for comp in "${components[@]}"; do
    echo "$comp"
  done
}

# 6) FLAG PARSING
SKIP_CONFIRM=false
NO_IGNORE=false
LIST_IGNORES=false
SHOW_HELP=false
PRINT_CONTENT=false
RESET_CONFIG=false
IGNORE_OPS=()
raw_inputs=()

while (( $# )); do
  case "$1" in
    --yes|-y)       SKIP_CONFIRM=true;    shift ;;
    --no-ignore)    NO_IGNORE=true;       shift ;;
    --list-ignores) LIST_IGNORES=true;    shift ;;
    --print)        PRINT_CONTENT=true;   shift ;;
    --reset-config) RESET_CONFIG=true;    shift ;;
    --help|-h)      SHOW_HELP=true;       shift ;;
    --ignore)
      shift
      [[ $# -eq 0 ]] && { printf "%s\n" "${CLR_ERROR}Error: --ignore requires arguments.${RESET}" >&2; exit 1; }
      while (( $# )) && [[ $1 =~ ^(d?[+-]) ]]; do
        IGNORE_OPS+=( "$1" )
        shift
      done
      ;;
    --) shift; raw_inputs+=( "$@" ); break ;;
    --*) 
      printf "%s\n" "${CLR_ERROR}Error: Unknown option '$1'${RESET}" >&2
      printf "Try '${CLR_SUCCESS}catclip${RESET} --help' for available options.\n" >&2
      exit 1
      ;;
    *)   raw_inputs+=( "$1" ); shift ;;
  esac
done

[[ "$SHOW_HELP" == true ]] && { print_help; exit 0; }

if [[ "$RESET_CONFIG" == true ]]; then
  echo "${CLR_WARN}This will overwrite ${BOLD}$CONFIG${RESET}${CLR_WARN} with factory defaults.${RESET}" >&2
  read -r -p "Are you sure? [y/N] " confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    get_default_config > "$CONFIG"
    echo "${CLR_SUCCESS}Configuration restored.${RESET}" >&2
  else
    echo "Cancelled." >&2
  fi
  exit 0
fi

# 7) LOAD IGNORES
ignore_dirs=()
ignore_files=()
parse_error=false
error_msg=""

if [[ -r "$CONFIG" ]]; then
  while IFS='|' read -r type value; do
    if [[ "$type" == "ERR" ]]; then
      parse_error=true
      error_msg="$value"
      break
    elif [[ "$type" == "D" ]]; then
      ignore_dirs+=( "$value" )
    elif [[ "$type" == "F" ]]; then
      ignore_files+=( "$value" )
    fi
  done < <(awk '
    { raw = $0; sub(/#.*/, ""); gsub(/^[ \t]+|[ \t]+$/, ""); }
    length($0) == 0 { next }
    /^ignore_dirs:/  { block="D"; next }
    /^ignore_files:/ { block="F"; next }
    /^- / {
      if (block == "") { print "ERR|Orphaned item: " raw; exit 1 }
      sub(/^- /, ""); gsub(/^["\x27]|["\x27]$/, "");
      if (block == "D") print "D|" $0;
      if (block == "F") print "F|" $0;
      next
    }
    { print "ERR|Syntax error: " raw; exit 1 }
  ' "$CONFIG")
fi

if [[ "$parse_error" == true ]]; then
  printf "\n%s\n" "${CLR_ERROR}Config Corrupted in ${BOLD}$CONFIG${RESET}" >&2
  printf "%s\n" "${CLR_ERROR}➤ $error_msg${RESET}" >&2
  printf "\n${CLR_WARN}Would you like to reset to factory defaults? [y/N]${RESET} " >&2
  read -r -n 1 response < /dev/tty
  echo
  if [[ "$response" =~ ^[Yy]$ ]]; then
    get_default_config > "$CONFIG"
    echo "${CLR_SUCCESS}Configuration reset. Retrying...${RESET}" >&2
    exec "$0" "$@"
  else
    echo "${CLR_ERROR}Aborting. Please fix the file manually.${RESET}" >&2
    exit 1
  fi
fi

# 8) CONFIG UPDATE LOGIC
if (( ${#IGNORE_OPS[@]} > 0 )); then
  printf "%s\n" "${BOLD}Updating ignore list in ${DIM}$CONFIG${RESET}" >&2
  changes_log=()

  for op in "${IGNORE_OPS[@]}"; do
    case "$op" in
      d+*) 
           dir_name="${op:2}"
           ignore_dirs+=( "$dir_name" )
           changes_log+=( "${CLR_SUCCESS}+${RESET} ${CLR_DIR}${dir_name}${RESET}" )
           ;;
      d-*) 
           new_dirs=()
           for d in "${ignore_dirs[@]}"; do [[ "$d" != "${op:2}" ]] && new_dirs+=("$d"); done
           ignore_dirs=("${new_dirs[@]}")
           changes_log+=( "${CLR_ERROR}-${RESET} ${CLR_DIR}${op:2}${RESET}" )
           ;;
      +*)  
           file_pattern="${op:1}"
           ignore_files+=( "$file_pattern" )
           changes_log+=( "${CLR_SUCCESS}+${RESET} ${file_pattern}" ) 
           ;;
      -*)  
           new_files=()
           for f in "${ignore_files[@]}"; do [[ "$f" != "${op:1}" ]] && new_files+=("$f"); done
           ignore_files=("${new_files[@]}")
           changes_log+=( "${CLR_ERROR}-${RESET} ${op:1}" )
           ;;
    esac
  done

  {
    echo "ignore_dirs:"
    for d in "${ignore_dirs[@]}"; do echo "  - $d"; done
    echo "ignore_files:"
    for f in "${ignore_files[@]}"; do echo "  - \"$f\""; done
  } >"$CONFIG"

  printf "\n${BOLD}New Configuration:${RESET}\n" >&2
  printf "\n${BOLD}Ignored Directories (YAML):${RESET}\n" >&2
  for d in "${ignore_dirs[@]}"; do printf "  ${CLR_ERROR}•${RESET} ${CLR_DIR}%s${RESET}\n" "$d" >&2; done
  printf "\n${BOLD}Ignored Files (YAML):${RESET}\n" >&2
  for f in "${ignore_files[@]}"; do printf "  ${CLR_WARN}•${RESET} %s\n" "$f" >&2; done

  printf "\n${BOLD}Changes applied:${RESET}\n" >&2
  for change in "${changes_log[@]}"; do printf "  %s\n" "$change" >&2; done

  if git rev-parse --show-toplevel &>/dev/null; then
    printf "\n${CLR_GIT}Note: Files listed in .gitignore remain excluded automatically.${RESET}\n" >&2
  else
    printf "\n${DIM}Note: If used inside a Git project, .gitignore rules will also apply.${RESET}\n" >&2
  fi
  exit 0
fi

# 9) LIST IGNORES COMMAND
if [[ "$LIST_IGNORES" == true ]]; then
  printf "%s\n" "${BOLD}Current Configuration${RESET}" >&2
  printf "${DIM}%s${RESET}\n" "$CONFIG" >&2
  
  printf "\n${BOLD}Ignored Directories (YAML):${RESET}\n" >&2
  for d in "${ignore_dirs[@]:-}"; do printf "  ${CLR_ERROR}•${RESET} ${CLR_DIR}%s${RESET}\n" "$d" >&2; done
  
  printf "\n${BOLD}Ignored Files (YAML):${RESET}\n" >&2
  for f in "${ignore_files[@]:-}"; do printf "  ${CLR_WARN}•${RESET} %s\n" "$f" >&2; done

  if git rev-parse --show-toplevel &>/dev/null; then
    git_root=$(git rev-parse --show-toplevel)
    git_ignore_file="$git_root/.gitignore"
    if [[ -f "$git_ignore_file" ]]; then
      printf "\n${BOLD}Ignored Files (Project .gitignore):${RESET}\n" >&2
      printf "${DIM}%s${RESET}\n" "$git_ignore_file" >&2
      grep -vE '^\s*#|^\s*$' "$git_ignore_file" | while read -r line; do
        printf "  ${CLR_GIT}•${RESET} %s\n" "$line" >&2
      done
    else
      printf "\n${DIM}(No .gitignore found in project root)${RESET}\n" >&2  
    fi
  fi
  exit 0
fi

# 10) TARGET RESOLUTION (NEW SMART PATH RESOLUTION)
(( ${#raw_inputs[@]} == 0 )) && raw_inputs=( "." )

IS_GIT=false
if git rev-parse --show-toplevel &>/dev/null 2>&1; then IS_GIT=true; fi

file_targets=()
dir_targets=()

for arg in "${raw_inputs[@]}"; do
  
  if contains_parent_traversal "$arg"; then
    printf "%s\n" "${CLR_ERROR}Error: Cannot traverse above working directory: '$arg'${RESET}" >&2
    printf "${DIM}Hint: catclip must be run from project root and cannot access parent directories.${RESET}\n" >&2
    exit 1
  fi
  
  # BRANCH 1: Single word (no slashes) - local file/dir or fuzzy search
  if ! has_slashes "$arg"; then
    if [[ -d "$arg" ]]; then
      # Local directory exists - check if ignored
      if is_dir_ignored "./$arg"; then
        print_dir_ignore_msg "$arg" "error"
        exit 1
      fi
      dir_targets+=( "./$arg" )
      
    elif resolved_dir=$(fuzzy_search_dir "$arg"); then
      # Found matching directories via fuzzy search
      if is_dir_ignored "$resolved_dir"; then
        resolved_name=$(basename "$resolved_dir")
        print_dir_ignore_msg "$resolved_name" "error"
        exit 1
      fi
      dir_targets+=( "$resolved_dir" )
      
    elif [[ -f "$arg" ]]; then
      # Local file exists (only match if no directory found)
      if check_file_ignore "$arg"; then
        printf "%s\n" "${CLR_ERROR}Error: File '$arg' is ignored by pattern.${RESET}" >&2
        printf "${DIM}Use --no-ignore to include it anyway.${RESET}\n" >&2
        exit 1
      fi
      file_targets+=( "./$arg" )
      
    elif [[ "$arg" == *.* ]]; then
      # Looks like a filename but not found
      printf "%s\n" "${CLR_ERROR}Error: File '$arg' not found in working directory.${RESET}" >&2
      printf "\n${DIM}Hint: For files outside working directory, use:${RESET}\n" >&2
      printf "  ${CLR_SUCCESS}directory/filename${RESET}       ${DIM}(fuzzy search directory first)${RESET}\n" >&2
      printf "  ${CLR_SUCCESS}full/path/to/file${RESET}        ${DIM}(relative path from root)${RESET}\n" >&2
      exit 1
      
    else
      # No directory found, not a file
      printf "%s\n" "${CLR_ERROR}Error: No directory matching '$arg' found.${RESET}" >&2
      printf "\n${DIM}Searched for directories containing '%s' in their name.${RESET}\n" "$arg" >&2
      printf "\n${DIM}Try:${RESET}\n" >&2
      printf "  ${CLR_SUCCESS}catclip .${RESET}                ${DIM}(copy current directory)${RESET}\n" >&2
      printf "  ${CLR_SUCCESS}catclip src${RESET}              ${DIM}(fuzzy match 'src' directory)${RESET}\n" >&2
      exit 1
    fi
    
  # BRANCH 2: Has slashes - path resolution (exact or chained)
  else
    filename="${arg##*/}"
    dir_path="${arg%/*}"
    
    # First check if exact path already exists
    if [[ -e "$arg" ]]; then
      # Exact path exists - use it directly
      if [[ -f "$arg" ]]; then
        if check_file_ignore "$filename"; then
          printf "%s\n" "${CLR_ERROR}Error: File '$filename' is ignored by pattern.${RESET}" >&2
          printf "${DIM}Use --no-ignore to include it anyway.${RESET}\n" >&2
          exit 1
        fi
        if ! is_text_file "$arg"; then
          printf "%s\n" "${CLR_ERROR}Error: File '$filename' is a binary file and cannot be copied.${RESET}" >&2
          exit 1
        fi
        file_targets+=( "$arg" )
        
      elif [[ -d "$arg" ]]; then
        dirname_base=$(basename "$arg")
        if is_dir_ignored "$arg"; then
          print_dir_ignore_msg "$dirname_base" "warning"
        fi
        dir_targets+=( "$arg" )
      fi
      
    else
      # Path doesn't exist - use chained resolution
      if ! resolved_dir=$(resolve_chained_path "$dir_path"); then
        exit 1
      fi
      
      full_path="$resolved_dir/$filename"
      
      if [[ -d "$full_path" ]]; then
        if is_dir_ignored "$full_path"; then
          resolved_name=$(basename "$full_path")
          print_dir_ignore_msg "$resolved_name" "error"
          exit 1
        fi
        dir_targets+=( "$full_path" )
        
      elif [[ -f "$full_path" ]]; then
        if is_dir_ignored "$resolved_dir"; then
          resolved_name=$(basename "$resolved_dir")
          print_dir_ignore_msg "$resolved_name" "warning"
        fi
        if ! is_text_file "$full_path"; then
          printf "%s\n" "${CLR_ERROR}Error: File '$filename' is a binary file and cannot be copied.${RESET}" >&2
          exit 1
        fi
        if check_file_ignore "$filename"; then
          printf "%s\n" "${CLR_ERROR}Error: File '$filename' is ignored by pattern.${RESET}" >&2
          printf "${DIM}Use --no-ignore to include it anyway.${RESET}\n" >&2
          exit 1
        fi
        file_targets+=( "$full_path" )
        
      else
        printf "%s\n" "${CLR_ERROR}Error: '$filename' not found in directory '$resolved_dir'${RESET}" >&2
        printf "${DIM}Searched in: $full_path${RESET}\n" >&2
        exit 1
      fi
    fi
  fi
done

if (( ${#file_targets[@]} == 0 && ${#dir_targets[@]} == 0 )); then
  printf "%s\n" "${CLR_ERROR}Error: No valid targets specified.${RESET}" >&2
  exit 1
fi

# 11) BUILD FALLBACK COMMANDS
find_opts=()
if [[ "$NO_IGNORE" == false ]] && (( ${#ignore_dirs[@]} > 0 )); then
  for d in "${ignore_dirs[@]}"; do find_opts+=( -name "$d" -prune -o ); done
fi
find_opts+=( -type f )
find_opts+=( -print0 )

# 12) PHASE 1: DISCOVERY
LISTFILE="$(mktemp)"
count=0

printf "\n${BOLD}Discovering files...${RESET}\n\n" >&2

# PHASE 1A: Process individual files
if (( ${#file_targets[@]} > 0 )); then
  for f in "${file_targets[@]}"; do
    if is_text_file "$f"; then
      normalized="${f#./}"
      echo "$normalized" >> "$LISTFILE"
      ((count++))
      printf "${CLR_LABEL}[%d]${RESET} ${DIM}%s${RESET}\n" "$count" "$normalized" >&2
    fi
  done
fi

# PHASE 1B: Process directories
if [[ "$IS_GIT" == true && "$NO_IGNORE" == false ]] && (( ${#dir_targets[@]} > 0 )); then
  # GIT MODE
  for tgt in "${dir_targets[@]}"; do
    while IFS= read -r f; do
       filename=$(basename "$f")
       skip=false
       if (( ${#ignore_files[@]} > 0 )); then
         for pat in "${ignore_files[@]}"; do
           if [[ "$filename" == $pat ]]; then skip=true; break; fi
         done
       fi
       [[ "$skip" == true ]] && continue
       
       [[ -f "$f" ]] || continue
       
       if is_text_file "$f"; then
         echo "$f" >> "$LISTFILE"
         ((count++))
         if (( count % 10 == 0 )); then
           printf "${CLR_LABEL}[%d]${RESET} ${DIM}%s${RESET}\n" "$count" "$f" >&2
         fi
       fi
    done < <(git ls-files --cached --others --exclude-standard "$tgt")
  done
elif (( ${#dir_targets[@]} > 0 )); then
  # FALLBACK MODE (FIND)
  for tgt in "${dir_targets[@]}"; do
    files_to_process=()
    if (( ${#find_opts[@]} > 0 )); then
      while IFS= read -r -d '' f; do files_to_process+=( "$f" ); done < <(find "$tgt" "${find_opts[@]}")
    else
      while IFS= read -r -d '' f; do files_to_process+=( "$f" ); done < <(find "$tgt" -type f -print0)
    fi

    if (( ${#files_to_process[@]} > 0 )); then
      for f in "${files_to_process[@]}"; do
        if [[ "$NO_IGNORE" == false ]] && (( ${#ignore_files[@]} > 0 )); then
          filename=$(basename "$f")
          skip=false
          for pat in "${ignore_files[@]}"; do
             if [[ "$filename" == $pat ]]; then skip=true; break; fi
          done
          [[ "$skip" == true ]] && continue
        fi
        
        if is_text_file "$f"; then
          echo "${f#./}" >> "$LISTFILE"
          ((count++))
          if (( count % 10 == 0 )); then
            printf "${CLR_LABEL}[%d]${RESET} ${DIM}%s${RESET}\n" "$count" "${f#./}" >&2
          fi
        fi
      done
    fi
  done
fi

if [[ ! -s "$LISTFILE" ]]; then
  printf "%s\n" "${CLR_WARN}No text files found.${RESET}" >&2
  exit 1
fi

# 13) PHASE 2: PREVIEW & ANALYSIS
total_bytes=0
if [[ -s "$LISTFILE" ]]; then
  total_bytes=$(cat "$LISTFILE" | tr '\n' '\0' | xargs -0 stat -f %z 2>/dev/null | awk '{s+=$1} END {print s+0}' || echo 0)
fi

total_bytes=$((total_bytes + (count * 30)))
human_size=$(format_size "$total_bytes")

est_tokens=$((total_bytes / 4))
TOKEN_WARN_LIMIT=32000

printf "\n${BOLD}Files to Copy:${RESET}\n" >&2

if [[ "$NO_IGNORE" == true ]]; then
  printf "  ${CLR_WARN}⚠️  Filters DISABLED (--no-ignore)${RESET}\n" >&2
elif [[ "$IS_GIT" == true ]]; then
  printf "  ${CLR_GIT}Excluding files in .gitignore and %s${RESET}\n" "$CONFIG" >&2
else
  printf "  ${CLR_WARN}No .gitignore found, excluding files in %s${RESET}\n" "$CONFIG" >&2
fi

print_tree "$LISTFILE" >&2
printf "\n" >&2

if (( est_tokens > TOKEN_WARN_LIMIT )); then
  printf "  ${CLR_WARN}⚠️  Warning: ~%d tokens. This may exceed the context window of some LLMs.%s\n" "$est_tokens" "${RESET}" >&2
fi

printf "  ${CLR_LABEL}%-8s${RESET} ${CLR_VALUE}%d files${RESET}\n" "Count:" "$count" >&2
printf "  ${CLR_LABEL}%-8s${RESET} ${CLR_VALUE}%s${RESET}\n" "Size:" "$human_size" >&2
printf "  ${CLR_LABEL}%-8s${RESET} ${CLR_VALUE}~%d${RESET}\n" "Tokens:" "$est_tokens" >&2

# 14) AUTO-CONFIRMATION LOGIC
if [[ "$SKIP_CONFIRM" == false && $est_tokens -gt $TOKEN_WARN_LIMIT ]]; then
  printf "\n${CLR_PROMPT}Proceed with copy? [y/N] ${RESET}" >&2
  read -r -n 1 response
  echo >&2
  if [[ ! "$response" =~ ^[Yy]$ ]]; then
    printf "${CLR_WARN}Aborted.${RESET}\n" >&2
    exit 0
  fi
fi

# 15) PHASE 3: EXECUTION
TMPFILE="$(mktemp)"

while IFS= read -r rel_path; do
  f="./$rel_path"
  if [[ -f "$f" ]]; then
    { echo "# File: $rel_path"; cat "$f"; echo ""; } >> "$TMPFILE"
  fi
done < "$LISTFILE"

pbcopy < "$TMPFILE"
printf "\n${CLR_SUCCESS}✔${RESET} ${BOLD}Copied to clipboard!${RESET}\n" >&2

if [[ "$PRINT_CONTENT" == true ]]; then
  cat "$TMPFILE"
fi
