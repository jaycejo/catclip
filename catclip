#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# catclip - Context Gatherer for LLMs (OPTIMIZED FOR SPEED)
#
# A robust tool to gather code context while respecting .gitignore rules.
#
# DESIGN PHILOSOPHY:
# 1. Safety First: Don't leak secrets (.env) or junk (node_modules) by default.
# 2. Native Dependencies: Use standard tools (awk, find, git) to avoid npm/pip deps.
# 3. Git-Aware: Rely on 'git ls-files' as the source of truth when possible.
# 4. Self-Healing: Contains embedded defaults to restore config if missing/broken.
# 5. SPEED: Minimizes I/O overhead via smart pruning, extension checks, and batching.
# ------------------------------------------------------------------------------

# SAFETY BOILERPLATE
# set -e: Exit immediately if a command exits with a non-zero status.
# set -u: Treat unset variables as an error (prevents accidental "rm -rf /" scenarios).
# set -o pipefail: If any command in a pipeline fails, the whole pipe fails.
set -euo pipefail

# Internal Field Separator: Set to newline and tab only.
# This ensures filenames with spaces are handled correctly.
IFS=$'\n\t'

# 0) TERMINAL CONFIGURATION
# Force 256-color mode so output looks good even in restricted shells.
export TERM="${TERM:-xterm-256color}"

# 1) PREREQUISITE CHECKS
# Fail fast if essential tools are missing.
for cmd in pbcopy find mktemp awk stat git file; do
  if ! command -v "$cmd" &>/dev/null; then
    echo "Error: '$cmd' is required but not found in PATH." >&2
    exit 1
  fi
done

# 2) COLORS & THEME
# We use ANSI escape codes. Variables make the code readable.
RESET=$'\033[0m'
BOLD=$'\033[1m'
DIM=$'\033[2m'
RED=$'\033[31m'
GREEN=$'\033[32m'
YELLOW=$'\033[33m'
BLUE=$'\033[34m'
MAGENTA=$'\033[35m'
CYAN=$'\033[36m'

# Semantic Variables allow us to change the theme easily in one place.
CLR_SUCCESS=$'\033[32m'
CLR_ERROR=$'\033[31m'
CLR_WARN=$'\033[33m'
CLR_DIR=$'\033[1;34m'
CLR_LABEL=$'\033[90m'
CLR_VALUE=$'\033[1m'
CLR_TREE=$'\033[90m'
CLR_PROMPT=$'\033[36m'
CLR_GIT=$'\033[35m'
CLR_DIM=$'\033[2m' 

# 3) CONFIGURATION MANAGEMENT
# Adhere to XDG Base Directory specification ($HOME/.config).
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/catclip"
CONFIG="$CONFIG_DIR/ignore.yaml"

# EMBEDDED DEFAULTS (The "Factory Reset" State)
get_default_config() {
  cat <<'EOF'
ignore_dirs:
  # Version Control
  - .git
  - .svn
  - .hg
  
  # IDEs & Editors
  - .idea
  - .vscode
  - .cursor
  - .history
  
  # JavaScript / Node
  - node_modules
  - bower_components
  - jspm_packages
  - coverage
  - .npm
  - .yarn
  - .pnpm-store
  
  # Python
  - __pycache__
  - venv
  - .venv
  - env
  - .pytest_cache
  - .mypy_cache
  - .tox
  - htmlcov
  
  # Java / Build
  - target
  - build
  - dist
  - out
  - bin
  - obj
  - .gradle
  
  # Web Frameworks
  - .next
  - .nuxt
  - .serverless
  - .turbo
  
  # Test directories (usually noise for LLM context)
  - test
  - tests
  - __tests__
  - fixtures
  - __fixtures__

ignore_files:
  # System
  - .DS_Store
  - .AppleDouble
  - .LSOverride

  # Binaries & Archives
  - "*.class"
  - "*.pyc"
  - "*.pyo"
  - "*.exe"
  - "*.dll"
  - "*.so"
  - "*.dylib"
  - "*.jar"
  - "*.war"
  - "*.zip"
  - "*.tar.gz"
  - "*.db"
  - "*.sqlite"
  
  # Media
  - "*.png"
  - "*.jpg"
  - "*.jpeg"
  - "*.gif"
  - "*.ico"
  - "*.svg"
  - "*.pdf"
  - "*.mov"
  - "*.mp4"
  - "*.webm"

  # Lockfiles
  - package-lock.json
  - yarn.lock
  - pnpm-lock.yaml
  - poetry.lock
  - Pipfile.lock
  - bun.lockb
  
  # Secrets (CRITICAL)
  - .env
  - .env.local
  - .env.*
  - "*.pem"
  - "*.key"
  - id_rsa
  - application.properties
  - application.yml

  # Logs
  - "*.log"
  - "*.tmp"
  - "*.bak"
  - "*.swp"
EOF
}

# Auto-Create if missing
if [[ ! -f "$CONFIG" ]]; then
  mkdir -p "$CONFIG_DIR"
  get_default_config > "$CONFIG"
fi

# 4) CLEANUP TRAPS
# Use 'mktemp' for atomic temporary files.
# The 'trap' ensures files are deleted even if the user Ctrl+C's the script.
TMPFILE=""
LISTFILE=""
UTF16_LIST=""
cleanup() {
  [[ -n "$TMPFILE" && -f "$TMPFILE" ]] && rm -f "$TMPFILE"
  [[ -n "$LISTFILE" && -f "$LISTFILE" ]] && rm -f "$LISTFILE"
  [[ -n "$UTF16_LIST" && -f "$UTF16_LIST" ]] && rm -f "$UTF16_LIST"
}
trap cleanup EXIT

# 5) HELPER FUNCTIONS

# format_size: Converts bytes to human-readable (KB, MB) using awk.
# We use awk because bash does not support floating point math natively.
format_size() {
  awk -v b="$1" 'BEGIN {
    split("B KB MB GB TB", units);
    u=1;
    while(b >= 1024 && u < 5) { b/=1024; u++ }
    printf "%.2f%s", b, units[u]
  }'
}

# print_tree: Generates a visual tree structure from a flat list of paths.
# This logic parses path strings (e.g., "src/components/Button.tsx") and
# draws the corresponding ASCII indentation.
print_tree() {
  local list_file="$1"
  sort "$list_file" | awk -v dir_col="$CLR_DIR" -v reset="$RESET" -v tree_col="$CLR_TREE" -F/ '
  {
    for (i=1; i<NF; i++) {
      if ($i != last[i]) {
        for (j=1; j<i; j++) printf tree_col "│   " reset
        if (i == 1) printf "" 
        else printf tree_col "├── " reset
        print dir_col $i "/" reset
        last[i] = $i
        for (k=i+1; k<=20; k++) delete last[k]
      }
    }
    for (j=1; j<NF; j++) printf tree_col "│   " reset
    printf tree_col "├── " reset
    print $NF
    delete last[NF]
  }'
}

print_help() {
  cat <<EOF
${BOLD}catclip${RESET} - Copy code context for AI prompts

  Recursively copies code files to your clipboard with a visual tree preview.
  Automatically filters out secrets, binaries, and build artifacts.
  Respects ${BOLD}.gitignore${RESET} and your ${BOLD}ignore list${RESET}.

${BOLD}Output Format:${RESET}
  Each file is prefixed with ${DIM}# File: path/to/file${RESET} so AI can see the structure.

${BOLD}Usage:${RESET}
  catclip [OPTIONS] [TARGETS...]

${BOLD}Targets:${RESET}
  Specify what to copy:
    ${CYAN}No arguments${RESET}      → Recursively copy current directory (respects ignore list)
    
    ${CYAN}Directory name${RESET}    → Recursively copy specific directory.
                          Just use the name - searches anywhere (e.g., 'utils' finds 'src/utils').
    
    ${CYAN}File path(s)${RESET}      → Copy specific files.
                          ${BOLD}Note:${RESET} Files need the relative path (e.g., ${DIM}src/App.tsx${RESET}).

${BOLD}Options:${RESET}
  ${GREEN}--help, -h${RESET}
      Show this help message.

  ${GREEN}--no-ignore${RESET}
      ${BOLD}Temporarily${RESET} bypass all ignore rules for this copy only.
      Useful for copying build folders, lockfiles, or other normally-excluded files.
      
      ${DIM}catclip --no-ignore dist${RESET}            # Copy entire dist folder
      ${DIM}catclip --no-ignore .env.local${RESET}      # Copy a secret file (be careful!)

  ${GREEN}--yes, -y${RESET}
      Skip confirmation prompt (useful for large copies or scripts).
      ${DIM}catclip -y dist${RESET}                       # Auto-confirm even if >32k tokens

  ${GREEN}--print${RESET}
      Print to terminal in addition to copying to clipboard.
      
      ${DIM}catclip --print${RESET}                      # View in terminal + copy to clipboard
      ${DIM}catclip --print src > context.txt${RESET}    # Save to file + copy to clipboard
      ${DIM}catclip --print | wc -l${RESET}              # Count lines before copying

  ${GREEN}--list-ignores${RESET}
      Show what files and directories are currently being ignored
      (from both your config and .gitignore if in a git repo).

  ${GREEN}--ignore [OPERATIONS]${RESET}
      Permanently modify your ignore list in ${DIM}~/.config/catclip/ignore.yaml${RESET}.
      
      ${BOLD}Add/remove files:${RESET}  +'pattern'  -'pattern'  ${DIM}(quotes needed for wildcards like *.map)${RESET}
      ${BOLD}Add/remove dirs:${RESET}   d+dirname  d-dirname   ${DIM}(no quotes needed)${RESET}
      
      You can combine multiple changes in one command:
      
      ${DIM}# Stop ignoring dist folder, but ignore sourcemaps and test coverage${RESET}
      ${DIM}catclip --ignore d-dist +'*.map' d+coverage${RESET}
      
      ${DIM}# Clean up: remove yarn.lock from ignore, add bun.lockb instead${RESET}
      ${DIM}catclip --ignore -'yarn.lock' +'bun.lockb'${RESET}
  
  ${GREEN}--reset-config${RESET}
      Restore the configuration file to factory defaults.

${BOLD}Examples:${RESET}
  ${DIM}# Copy everything in current project${RESET}
  ${GREEN}catclip${RESET}
  
  ${DIM}# Copy just the src folder${RESET}
  ${GREEN}catclip${RESET} src
  
  ${DIM}# Copy utils (finds it anywhere: src/utils, lib/utils, etc)${RESET}
  ${GREEN}catclip${RESET} utils
  
  ${DIM}# Copy specific files for debugging${RESET}
  ${GREEN}catclip${RESET} package.json src/api/routes.ts src/lib/db.ts
  
  ${DIM}# Save to file (also copies to clipboard)${RESET}
  ${GREEN}catclip --print${RESET} src > context.txt
  
  ${DIM}# Override ignore rules to copy build output${RESET}
  ${GREEN}catclip --no-ignore${RESET} dist
  
  ${DIM}# Permanently exclude all .test.ts files${RESET}
  ${GREEN}catclip --ignore${RESET} +'*.test.ts'

${BOLD}Config Location:${RESET}
  ${DIM}$CONFIG${RESET}
EOF
}

# ------------------------------------------------------------------------------
# OPTIMIZED BINARY DETECTION
# ------------------------------------------------------------------------------
# Strategy:
# 1. Use 'file --mime' which is MUCH faster than grep -Iq
# 2. Batch process files to reduce syscalls
# 3. Cache common file extensions

# Fast binary check using extension first, then file command
is_text_file() {
  local f="$1"
  local ext="${f##*.}"
  
  # Quick wins based on extension - binary files (reject immediately)
  case "$ext" in
    png|jpg|jpeg|gif|bmp|ico|svg|webp|pdf|\
    zip|tar|gz|bz2|xz|7z|rar|dmg|iso|\
    exe|dll|so|dylib|a|lib|o|obj|class|jar|war|ear|\
    pyc|pyo|pyd|wasm|\
    mp3|mp4|mov|avi|mkv|webm|flv|wmv|m4a|wav|flac|\
    ttf|otf|woff|woff2|eot|\
    db|sqlite|sqlite3)
      return 1
      ;;
  esac
  
  # Quick wins based on extension - trust common text files
  case "$ext" in
    txt|md|markdown|json|yaml|yml|xml|html|htm|css|scss|sass|less|\
    js|jsx|mjs|cjs|ts|tsx|mts|cts|\
    py|pyw|pyi|rb|java|php|sh|bash|zsh|fish|sql|\
    c|cc|cpp|cxx|h|hh|hpp|hxx|\
    go|rs|swift|kt|kts|scala|cs|fs|vb|vbs|\
    gd|godot|shader|unity|\
    makefile|Makefile|mk|cmake|gradle|jenkinsfile|Jenkinsfile|\
    dockerfile|Dockerfile|groovy|gvy|tf|hcl|toml|ini|cfg|conf|properties|\
    sln|csproj|vbproj|\
    r|R|clj|cljs|ex|exs|erl|hrl|elm|nim|zig|v|d|m|mm|\
    hs|lhs|jl|cl|lisp|rkt|\
    csv|tsv|patch|diff|lock|\
    graphql|gql|proto|sol|ps1|psm1|psd1|bat|cmd|asm|s|\
    vim|lua|pl|pm|dart|vue|svelte|astro|\
    rst|adoc|tex|j2|ejs|hbs|mustache|liquid)
      return 0
      ;;
  esac
  
  # For unknown extensions, use file command
  local mime
  mime=$(file -b --mime "$f" 2>/dev/null)
  
  # Reject UTF-16, UTF-32, and explicitly binary files
  [[ "$mime" =~ utf-16 ]] && return 1
  [[ "$mime" =~ utf-32 ]] && return 1
  [[ "$mime" =~ binary ]] && return 1
  
  # Allow common text mime types
  [[ "$mime" == text/* ]] && return 0
  [[ "$mime" =~ application/json ]] && return 0
  [[ "$mime" =~ application/xml ]] && return 0
  [[ "$mime" =~ application/javascript ]] && return 0
  [[ "$mime" =~ application/x-sh ]] && return 0
  [[ "$mime" =~ application/x-yaml ]] && return 0
  
  # Empty files are considered text
  [[ ! -s "$f" ]] && return 0
  
  return 1
}

# ------------------------------------------------------------------------------
# 6) FLAG PARSING
# ------------------------------------------------------------------------------
# Default states
SKIP_CONFIRM=false
NO_IGNORE=false
LIST_IGNORES=false
SHOW_HELP=false
PRINT_CONTENT=false
RESET_CONFIG=false
IGNORE_OPS=()
raw_inputs=()

# Process arguments
while (( $# )); do
  case "$1" in
    --yes|-y)       SKIP_CONFIRM=true;    shift ;;
    --no-ignore)    NO_IGNORE=true;       shift ;;
    --list-ignores) LIST_IGNORES=true;    shift ;;
    --print)        PRINT_CONTENT=true;   shift ;;
    --reset-config) RESET_CONFIG=true;    shift ;;
    --help|-h)      SHOW_HELP=true;       shift ;;
    --ignore)
      shift
      [[ $# -eq 0 ]] && { printf "%s\n" "${CLR_ERROR}Error: --ignore requires arguments.${RESET}" >&2; exit 1; }
      # Only support legacy syntax (d+, d-, +, -)
      while (( $# )) && [[ $1 =~ ^(d?[+-]) ]]; do
        IGNORE_OPS+=( "$1" )
        shift
      done
      ;;
    --) shift; raw_inputs+=( "$@" ); break ;;
    --*) 
      printf "%s\n" "${CLR_ERROR}Error: Unknown option '$1'${RESET}" >&2
      printf "Try '${GREEN}catclip${RESET} --help' for available options.\n" >&2
      exit 1
      ;;
    *)   raw_inputs+=( "$1" ); shift ;;
  esac
done

[[ "$SHOW_HELP" == true ]] && { print_help; exit 0; }

# Reset Config Handler
if [[ "$RESET_CONFIG" == true ]]; then
  echo "${YELLOW}This will overwrite ${BOLD}$CONFIG${RESET}${YELLOW} with factory defaults.${RESET}" >&2
  read -r -p "Are you sure? [y/N] " confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    get_default_config > "$CONFIG"
    echo "${GREEN}Configuration restored.${RESET}" >&2
  else
    echo "Cancelled." >&2
  fi
  exit 0
fi

# ------------------------------------------------------------------------------
# 7) LOAD IGNORES (OPTIMIZED YAML PARSING)
# ------------------------------------------------------------------------------
# We manually parse the simple YAML format to avoid requiring 'yq' dependency.
ignore_dirs=()
ignore_files=()
parse_error=false
error_msg=""

if [[ -r "$CONFIG" ]]; then
  # Pre-compile the awk script for faster execution
  while IFS='|' read -r type value; do
    if [[ "$type" == "ERR" ]]; then
      parse_error=true
      error_msg="$value"
      break
    elif [[ "$type" == "D" ]]; then
      ignore_dirs+=( "$value" )
    elif [[ "$type" == "F" ]]; then
      ignore_files+=( "$value" )
    fi
  done < <(awk '
    { raw = $0; sub(/#.*/, ""); gsub(/^[ \t]+|[ \t]+$/, ""); }
    length($0) == 0 { next }
    /^ignore_dirs:/  { block="D"; next }
    /^ignore_files:/ { block="F"; next }
    /^- / {
      if (block == "") { print "ERR|Orphaned item: " raw; exit 1 }
      sub(/^- /, ""); gsub(/^["\x27]|["\x27]$/, "");
      if (block == "D") print "D|" $0;
      if (block == "F") print "F|" $0;
      next
    }
    { print "ERR|Syntax error: " raw; exit 1 }
  ' "$CONFIG")
fi

# SELF-HEALING LOGIC
if [[ "$parse_error" == true ]]; then
  printf "\n%s\n" "${CLR_ERROR}Config Corrupted in ${BOLD}$CONFIG${RESET}" >&2
  printf "%s\n" "${CLR_ERROR}➤ $error_msg${RESET}" >&2
  printf "\n${YELLOW}Would you like to reset to factory defaults? [y/N]${RESET} " >&2
  read -r -n 1 response < /dev/tty
  echo
  if [[ "$response" =~ ^[Yy]$ ]]; then
    get_default_config > "$CONFIG"
    echo "${GREEN}Configuration reset. Retrying...${RESET}" >&2
    exec "$0" "$@"
  else
    echo "${RED}Aborting. Please fix the file manually.${RESET}" >&2
    exit 1
  fi
fi

# ------------------------------------------------------------------------------
# 8) CONFIG UPDATE LOGIC (--ignore)
# ------------------------------------------------------------------------------
if (( ${#IGNORE_OPS[@]} > 0 )); then
  printf "%s\n" "${BOLD}Updating ignore list in ${DIM}$CONFIG${RESET}" >&2
  changes_log=()

  for op in "${IGNORE_OPS[@]}"; do
    case "$op" in
      d+*) # Add Dir
           dir_name="${op:2}"
           ignore_dirs+=( "$dir_name" )
           changes_log+=( "${GREEN}+${RESET} ${CLR_DIR}${dir_name}${RESET}" )
           ;;
      d-*) # Remove Dir
           new_dirs=()
           for d in "${ignore_dirs[@]}"; do [[ "$d" != "${op:2}" ]] && new_dirs+=("$d"); done
           ignore_dirs=("${new_dirs[@]}")
           changes_log+=( "${RED}-${RESET} ${CLR_DIR}${op:2}${RESET}" )
           ;;
      +*)  # Add File
           file_pattern="${op:1}"
           ignore_files+=( "$file_pattern" )
           changes_log+=( "${GREEN}+${RESET} ${file_pattern}" ) 
           ;;
      -*)  # Remove File
           new_files=()
           for f in "${ignore_files[@]}"; do [[ "$f" != "${op:1}" ]] && new_files+=("$f"); done
           ignore_files=("${new_files[@]}")
           changes_log+=( "${RED}-${RESET} ${op:1}" )
           ;;
    esac
  done

  # Rewrite Config File
  {
    echo "ignore_dirs:"
    for d in "${ignore_dirs[@]}"; do echo "  - $d"; done
    echo "ignore_files:"
    for f in "${ignore_files[@]}"; do echo "  - \"$f\""; done
  } >"$CONFIG"

  # Display Status
  printf "\n${BOLD}New Configuration:${RESET}\n" >&2
  printf "\n${BOLD}Ignored Directories (YAML):${RESET}\n" >&2
  for d in "${ignore_dirs[@]}"; do printf "  ${CLR_ERROR}•${RESET} ${CLR_DIR}%s${RESET}\n" "$d" >&2; done
  printf "\n${BOLD}Ignored Files (YAML):${RESET}\n" >&2
  for f in "${ignore_files[@]}"; do printf "  ${CLR_WARN}•${RESET} %s\n" "$f" >&2; done

  printf "\n${BOLD}Changes applied:${RESET}\n" >&2
  for change in "${changes_log[@]}"; do printf "  %s\n" "$change" >&2; done

  if git rev-parse --show-toplevel &>/dev/null; then
    printf "\n${CLR_GIT}Note: Files listed in .gitignore remain excluded automatically.${RESET}\n" >&2
  else
    printf "\n${DIM}Note: If used inside a Git project, .gitignore rules will also apply.${RESET}\n" >&2
  fi
  exit 0
fi

# ------------------------------------------------------------------------------
# 9) LIST IGNORES COMMAND
# ------------------------------------------------------------------------------
if [[ "$LIST_IGNORES" == true ]]; then
  printf "%s\n" "${BOLD}Current Configuration${RESET}" >&2
  printf "${DIM}%s${RESET}\n" "$CONFIG" >&2
  
  printf "\n${BOLD}Ignored Directories (YAML):${RESET}\n" >&2
  for d in "${ignore_dirs[@]:-}"; do printf "  ${CLR_ERROR}•${RESET} ${CLR_DIR}%s${RESET}\n" "$d" >&2; done
  
  printf "\n${BOLD}Ignored Files (YAML):${RESET}\n" >&2
  for f in "${ignore_files[@]:-}"; do printf "  ${CLR_WARN}•${RESET} %s\n" "$f" >&2; done

  # Also show .gitignore if we are in a repo, so user sees full context
  if git rev-parse --show-toplevel &>/dev/null; then
    git_root=$(git rev-parse --show-toplevel)
    git_ignore_file="$git_root/.gitignore"
    if [[ -f "$git_ignore_file" ]]; then
      printf "\n${BOLD}Ignored Files (Project .gitignore):${RESET}\n" >&2
      printf "${DIM}%s${RESET}\n" "$git_ignore_file" >&2
      grep -vE '^\s*#|^\s*$' "$git_ignore_file" | while read -r line; do
        printf "  ${CLR_GIT}•${RESET} %s\n" "$line" >&2
      done
    else
      printf "\n${DIM}(No .gitignore found in project root)${RESET}\n" >&2  
    fi
  fi
  exit 0
fi

# ------------------------------------------------------------------------------
# 10) TARGET RESOLUTION (SMART SEARCH)
# ------------------------------------------------------------------------------
# If no args, default to current directory "."
(( ${#raw_inputs[@]} == 0 )) && raw_inputs=( "." )
targets=()

# Detect Git Root Early
IS_GIT=false
if git rev-parse --show-toplevel &>/dev/null 2>&1; then IS_GIT=true; fi

# Fuzzy Matching Logic
for arg in "${raw_inputs[@]}"; do
  if [[ -e "$arg" ]]; then
    targets+=( "$arg" )
  else
    # Fuzzy search for directories
    found=()
    
    # Build PRUNE options from YAML (optimization for 'find')
    search_prune_opts=()
    if [[ "$NO_IGNORE" == false ]]; then
      for d in "${ignore_dirs[@]:-}"; do 
        search_prune_opts+=( -name "$d" -prune -o )
      done
    fi

    # Use find to locate matching directories
    while IFS= read -r -d '' d; do 
      # Post-filter with git check-ignore if in a repo
      if [[ "$IS_GIT" == true && "$NO_IGNORE" == false ]]; then
        if git check-ignore -q "$d" 2>/dev/null; then 
          continue
        fi
      fi
      found+=( "$d" )
    done < <(find . "${search_prune_opts[@]}" -type d -name "*${arg}*" -not -path '*/.*' -print0 2>/dev/null)
    
    if (( ${#found[@]} == 0 )); then
      printf "%s\n" "${CLR_WARN}Warning: '$arg' not found.${RESET}" >&2
    elif (( ${#found[@]} == 1 )); then
      targets+=( "${found[0]}" )
    else
      # Prompt user if multiple folders match
      printf "%s\n" "${BOLD}Multiple matches for '$arg':${RESET}" >&2
      for i in "${!found[@]}"; do printf "  ${BOLD}%2d)${RESET} ${CLR_DIR}%s${RESET}\n" $((i+1)) "${found[i]}"; done >&2
      read -rp "Choose [1-${#found[@]}]: " c
      if [[ "$c" =~ ^[0-9]+$ ]] && (( c >= 1 && c <= ${#found[@]} )); then
        targets+=( "${found[c-1]}" )
      else
        printf "%s\n" "${CLR_ERROR}Invalid selection.${RESET}" >&2
        exit 1
      fi
    fi
  fi
done

(( ${#targets[@]} == 0 )) && exit 1

# ------------------------------------------------------------------------------
# 11) BUILD FALLBACK COMMANDS (OPTIMIZED)
# ------------------------------------------------------------------------------
# If not using git, we rely on 'find'. We pre-build the exclusion args here.
find_opts=()
if [[ "$NO_IGNORE" == false ]]; then
  for d in "${ignore_dirs[@]:-}"; do find_opts+=( -name "$d" -prune -o ); done
fi
find_opts+=( -type f )
find_opts+=( -print0 )

# ------------------------------------------------------------------------------
# 12) PHASE 1: DISCOVERY (HYBRID STRATEGY - RELIABLE)
# ------------------------------------------------------------------------------
# Strategy:
# 1. If inside a Git Repo: Use 'git ls-files'. Faster and Git-aware.
# 2. Else: Use 'find'. Manually filter out global ignores.

LISTFILE="$(mktemp)"
count=0

# Print header
printf "\n${BOLD}Discovering files...${RESET}\n\n" >&2

if [[ "$IS_GIT" == true && "$NO_IGNORE" == false ]]; then
  # --- GIT MODE ---
  # We use Process Substitution: < <(...) to keep variable scope (count).
  for tgt in "${targets[@]}"; do
    while IFS= read -r f; do
       # Apply additional YAML file-ignores (Git doesn't know about our local config)
       filename=$(basename "$f")
       skip=false
       for pat in "${ignore_files[@]:-}"; do
         if [[ "$filename" == $pat ]]; then skip=true; break; fi
       done
       [[ "$skip" == true ]] && continue
       
       # Check if file exists and is text
       [[ -f "$f" ]] || continue
       
       if is_text_file "$f"; then
         echo "$f" >> "$LISTFILE"
         ((count++))
         # Show every 10th file to reduce output but maintain feedback
         if (( count % 10 == 0 )); then
           printf "${CLR_LABEL}[%d]${RESET} ${CLR_DIM}%s${RESET}\n" "$count" "$f" >&2
         fi
       fi
    done < <(git ls-files --cached --others --exclude-standard "$tgt")
  done
else
  # --- FALLBACK MODE (FIND) ---
  for tgt in "${targets[@]}"; do
    if [[ -f "$tgt" ]]; then
      files_to_process=( "$tgt" )
    else
      files_to_process=()
      while IFS= read -r -d '' f; do files_to_process+=( "$f" ); done < <(find "$tgt" "${find_opts[@]}")
    fi

    for f in "${files_to_process[@]}"; do
      # Manual file-ignore check
      if [[ "$NO_IGNORE" == false ]]; then
        filename=$(basename "$f")
        skip=false
        for pat in "${ignore_files[@]:-}"; do
           if [[ "$filename" == $pat ]]; then skip=true; break; fi
        done
        [[ "$skip" == true ]] && continue
      fi
      
      # Binary check (optimized)
      if is_text_file "$f"; then
        echo "${f#./}" >> "$LISTFILE"
        ((count++))
        # Show every 10th file to reduce output but maintain feedback
        if (( count % 10 == 0 )); then
          printf "${CLR_LABEL}[%d]${RESET} ${CLR_DIM}%s${RESET}\n" "$count" "${f#./}" >&2
        fi
      fi
    done
  done
fi

if [[ ! -s "$LISTFILE" ]]; then
  printf "%s\n" "${CLR_WARN}No text files found.${RESET}" >&2
  exit 1
fi

# ------------------------------------------------------------------------------
# 13) PHASE 2: PREVIEW & ANALYSIS (OPTIMIZED SIZE CALCULATION)
# ------------------------------------------------------------------------------
# Optimization: Use xargs with stat for batch processing instead of loop.
# This prevents spawning a subshell for every single file.
total_bytes=0
if [[ -s "$LISTFILE" ]]; then
  # Batch process with xargs - much faster than loop
  # Use || true to handle any stat errors gracefully
  total_bytes=$(cat "$LISTFILE" | tr '\n' '\0' | xargs -0 stat -f %z 2>/dev/null | awk '{s+=$1} END {print s+0}' || echo 0)
fi

total_bytes=$((total_bytes + (count * 30))) # Add overhead for our injected headers
human_size=$(format_size "$total_bytes")

# Token Estimation:
# Rule of thumb: 1 token is approx 4 characters (bytes).
est_tokens=$((total_bytes / 4))
TOKEN_WARN_LIMIT=32000

printf "\n${BOLD}Files to Copy:${RESET}\n" >&2

if [[ "$NO_IGNORE" == true ]]; then
  printf "  ${CLR_WARN}⚠️  Filters DISABLED (--no-ignore)${RESET}\n" >&2
elif [[ "$IS_GIT" == true ]]; then
  printf "  ${CLR_GIT}Excluding files in .gitignore and %s${RESET}\n" "$CONFIG" >&2
else
  printf "  ${CLR_WARN}No .gitignore found, excluding files in %s${RESET}\n" "$CONFIG" >&2
fi

print_tree "$LISTFILE" >&2
printf "\n" >&2

# Warn if exceeding standard LLM context windows (32k is a safe common limit)
if (( est_tokens > TOKEN_WARN_LIMIT )); then
  printf "  ${CLR_WARN}⚠️  Warning: ~%d tokens. This may exceed the context window of some LLMs.%s\n" "$est_tokens" "${RESET}" >&2
fi

printf "  ${CLR_LABEL}%-8s${RESET} ${CLR_VALUE}%d files${RESET}\n" "Count:" "$count" >&2
printf "  ${CLR_LABEL}%-8s${RESET} ${CLR_VALUE}%s${RESET}\n" "Size:" "$human_size" >&2
printf "  ${CLR_LABEL}%-8s${RESET} ${CLR_VALUE}~%d${RESET}\n" "Tokens:" "$est_tokens" >&2

# 14) AUTO-CONFIRMATION LOGIC
# We interrupt the flow ONLY if:
# 1. The token count is dangerous.
# 2. The user did not explicitly allow it with -y.
if [[ "$SKIP_CONFIRM" == false && $est_tokens -gt $TOKEN_WARN_LIMIT ]]; then
  printf "\n${CLR_PROMPT}Proceed with copy? [y/N] ${RESET}" >&2
  read -r -n 1 response
  echo >&2
  if [[ ! "$response" =~ ^[Yy]$ ]]; then
    printf "${CLR_WARN}Aborted.${RESET}\n" >&2
    exit 0
  fi
fi

# ------------------------------------------------------------------------------
# 15) PHASE 3: EXECUTION (OPTIMIZED COPY)
# ------------------------------------------------------------------------------
TMPFILE="$(mktemp)"

# Read files and append headers
# We inject "# File: path/to/file" so the LLM knows where the code comes from.
while IFS= read -r rel_path; do
  f="./$rel_path"
  if [[ -f "$f" ]]; then
    { echo "# File: $rel_path"; cat "$f"; echo ""; } >> "$TMPFILE"
  fi
done < "$LISTFILE"

# Send to MacOS Clipboard
pbcopy < "$TMPFILE"
printf "\n${CLR_SUCCESS}✔${RESET} ${BOLD}Copied to clipboard!${RESET}\n" >&2

# Optional: Print to stdout (for piping to files)
if [[ "$PRINT_CONTENT" == true ]]; then
  cat "$TMPFILE"
fi