#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# catclip - Context Gatherer for LLMs
#
# Copies code files to clipboard with "# File: path" headers for AI prompts.
# Filters secrets, binaries, and build artifacts by default.
#
# DESIGN PHILOSOPHY:
# 1. Safety First: Don't leak secrets (.env) or junk (node_modules) by default.
# 2. Native Dependencies: Use standard tools (awk, find, git) to avoid npm/pip.
# 3. Git-Aware: Use 'git ls-files' as source of truth when in a repo.
# 4. Self-Healing: Embedded defaults restore config if missing/broken.
# 5. Speed: Extension checks before 'file' command, batch operations.
# 6. Bash 3.2: macOS ships old bash; avoid associative arrays, mapfile, |&.
# ------------------------------------------------------------------------------

# SAFETY BOILERPLATE
# set -e: Exit on command failure (fail-fast).
# set -u: Error on unset variables (prevents rm -rf / bugs).
# set -o pipefail: Fail if any pipeline command fails.
set -euo pipefail

# IFS: Only split on newline/tab, not space. Preserves filenames with spaces.
IFS=$'\n\t'

# 0) TERMINAL CONFIGURATION
# Force 256-color mode for consistent output in restricted shells.
export TERM="${TERM:-xterm-256color}"

# 0.5) OS DETECTION
# Detect OS once at startup for platform-specific behavior.
# WSL detected via /proc/version (contains "Microsoft" or "WSL").
detect_os() {
  case "$(uname -s)" in
    Darwin) echo "macos" ;;
    Linux)
      if [[ -f /proc/version ]] && grep -qiE '(microsoft|wsl)' /proc/version 2>/dev/null; then
        echo "wsl"
      else
        echo "linux"
      fi
      ;;
    CYGWIN*|MINGW*|MSYS*) echo "wsl" ;;  # Treat Cygwin/MinGW as WSL-like
    *) echo "unknown" ;;
  esac
}
OS_TYPE="$(detect_os)"

# 1) PREREQUISITE CHECKS
# Fail fast if essential tools are missing. Git and clipboard checked separately.
for cmd in find mktemp awk file; do
  if ! command -v "$cmd" &>/dev/null; then
    echo "Error: '$cmd' is required but not found in PATH." >&2
    exit 1
  fi
done

# Check for git (optional - enables .gitignore support)
HAS_GIT=false
if command -v git &>/dev/null; then
  HAS_GIT=true
fi

# 1.5) CLIPBOARD DETECTION
# Detect available clipboard command based on OS and display server.
# Session-aware: wl-copy only on Wayland, xclip/xsel only on X11.
detect_clipboard_cmd() {
  case "$OS_TYPE" in
    macos)
      if command -v pbcopy &>/dev/null; then
        echo "pbcopy"
        return 0
      fi
      ;;
    wsl)
      # WSL: prefer clip.exe for direct Windows clipboard
      if command -v clip.exe &>/dev/null; then
        echo "clip.exe"
        return 0
      fi
      ;;
  esac
  
  # Linux: detect display server and use appropriate tool
  local is_wayland=false
  if [[ "${XDG_SESSION_TYPE:-}" == "wayland" ]] || [[ -n "${WAYLAND_DISPLAY:-}" ]]; then
    is_wayland=true
  fi
  
  if [[ "$is_wayland" == true ]]; then
    # Wayland: prefer wl-copy, fall back to xclip/xsel (via XWayland)
    if command -v wl-copy &>/dev/null; then
      echo "wl-copy"
      return 0
    elif command -v xclip &>/dev/null; then
      echo "xclip -selection clipboard"
      return 0
    elif command -v xsel &>/dev/null; then
      echo "xsel --clipboard --input"
      return 0
    fi
  else
    # X11: prefer xclip/xsel, skip wl-copy (it won't work)
    if command -v xclip &>/dev/null; then
      echo "xclip -selection clipboard"
      return 0
    elif command -v xsel &>/dev/null; then
      echo "xsel --clipboard --input"
      return 0
    fi
  fi
  
  return 1
}

# 2) COLORS & THEME
# ANSI escape codes. Semantic naming (CLR_ERROR vs RED) for self-documenting code.
RESET=$'\033[0m'
BOLD=$'\033[1m'
DIM=$'\033[2m'
CYAN=$'\033[36m'
GREEN=$'\033[32m'
YELLOW=$'\033[33m'
RED=$'\033[31m'

# Semantic aliases for themed output
CLR_SUCCESS=$'\033[32m'
CLR_ERROR=$'\033[31m'
CLR_WARN=$'\033[33m'
CLR_DIR=$'\033[1;34m'
CLR_LABEL=$'\033[90m'
CLR_VALUE=$'\033[1m'
CLR_TREE=$'\033[90m'
CLR_PROMPT=$'\033[36m'
CLR_GIT=$'\033[35m'

# Prompt for y/n with a default without failing in non-interactive contexts.
# Sets PROMPT_RESPONSE to "y" or "n" (lowercase).
prompt_yn() {
  local prompt="$1"
  local default="$2" # "y" or "n"
  PROMPT_RESPONSE="$default"

  # Preferred: if stdout or stderr is a TTY, prompt there.
  if [[ -t 1 || -t 2 ]]; then
    printf "%s" "$prompt" >&2
    read -r -n 1 PROMPT_RESPONSE 2>/dev/null || PROMPT_RESPONSE="$default"
    echo >&2
  # Fallback: /dev/tty (may not exist in some contexts)
  elif [[ -r /dev/tty ]]; then
    if printf "%s" "$prompt" > /dev/tty 2>/dev/null; then
      read -r -n 1 PROMPT_RESPONSE < /dev/tty 2>/dev/null || PROMPT_RESPONSE="$default"
      printf "\n" >&2
    fi
  fi

  if [[ -z "$PROMPT_RESPONSE" ]]; then
    PROMPT_RESPONSE="$default"
  fi
  PROMPT_RESPONSE=$(printf "%s" "$PROMPT_RESPONSE" | tr 'A-Z' 'a-z')
}

# 3) CONFIGURATION MANAGEMENT
# XDG Base Directory spec: ~/.config/catclip/ignore.yaml
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/catclip"
CONFIG="$CONFIG_DIR/ignore.yaml"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PREFIX_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
SHARE_DIR="$PREFIX_DIR/share/catclip"
SHARE_TEMPLATE="$SHARE_DIR/ignore.yaml"
VERSION="dev"
if [[ -f "$SHARE_DIR/VERSION" ]]; then
  VERSION="$(tr -d ' \t\r\n' < "$SHARE_DIR/VERSION")"
elif [[ -f "$SCRIPT_DIR/VERSION" ]]; then
  VERSION="$(tr -d ' \t\r\n' < "$SCRIPT_DIR/VERSION")"
fi
if [[ -n "${CATCLIP_VERSION:-}" ]]; then
  VERSION="$CATCLIP_VERSION"
fi

# EMBEDDED DEFAULTS (The "Factory Reset" State)

get_default_config() {
  cat <<'EOF'
ignore_dirs:
  # Version Control
  - .git
  - .svn
  - .hg
  
  # IDEs & Editors
  - .idea
  - .vscode
  - .cursor
  - .history
  
  # JavaScript / Node
  - node_modules
  - bower_components
  - jspm_packages
  - coverage
  - .npm
  - .yarn
  - .pnpm-store
  
  # Python
  - __pycache__
  - venv
  - .venv
  - env
  - .pytest_cache
  - .mypy_cache
  - .tox
  - htmlcov
  
  # Java / Build
  - target
  - build
  - dist
  - out
  - bin
  - obj
  - .gradle
  
  # Web Frameworks
  - .next
  - .nuxt
  - .serverless
  - .turbo
  
  # Test directories
  - test
  - tests
  - __tests__
  - fixtures
  - __fixtures__

ignore_files:
  # System Files
  - .DS_Store
  - .AppleDouble
  - .LSOverride

  # Lockfiles (Text but Noisy - use --no-ignore if needed)
  - package-lock.json
  - yarn.lock
  - pnpm-lock.yaml
  - poetry.lock
  - Pipfile.lock
  - Gemfile.lock
  - composer.lock
  - Cargo.lock
  - go.sum
  
  # Secrets (CRITICAL - Never leak)
  - .env
  - .env.local
  - .env.*
  - "*.pem"
  - "*.key"
  - "*.p12"
  - "*.pfx"
  - id_rsa
  - id_ed25519
  - application.properties
  - application.yml
  - secrets.yaml
  - credentials.json

  # Logs & Temp
  - "*.log"
  - "*.tmp"
  - "*.bak"
  - "*.swp"
  - "*.swo"
EOF
}

# Check if config exists, prompt to create if missing
if [[ ! -f "$CONFIG" ]]; then
  printf "\n%s\n" "${CLR_WARN}Config Not Found: ${BOLD}$CONFIG${RESET}" >&2
  printf "%s\n" "${DIM}No ignore configuration exists.${RESET}" >&2
  prompt_yn "\n${CLR_WARN}Would you like to create default configuration? [Y/n]${RESET} " "y"
  if [[ "$PROMPT_RESPONSE" == "n" ]]; then
    echo "${CLR_WARN}Continuing without ignore rules (all text files will be included)...${RESET}" >&2
  else
    mkdir -p "$CONFIG_DIR"
    if [[ -f "$SHARE_TEMPLATE" ]]; then
      cp "$SHARE_TEMPLATE" "$CONFIG"
      echo "${CLR_SUCCESS}Default configuration copied from ${BOLD}$SHARE_TEMPLATE${RESET}" >&2
    else
      get_default_config > "$CONFIG"
      echo "${CLR_SUCCESS}Default configuration created at ${BOLD}$CONFIG${RESET}" >&2
    fi
  fi
fi

# 4) CLEANUP TRAPS
TMPFILE=""
LISTFILE=""
UTF16_LIST=""
cleanup() {
  [[ -n "$TMPFILE" && -f "$TMPFILE" ]] && rm -f "$TMPFILE"
  [[ -n "$LISTFILE" && -f "$LISTFILE" ]] && rm -f "$LISTFILE"
  [[ -n "$UTF16_LIST" && -f "$UTF16_LIST" ]] && rm -f "$UTF16_LIST"
  : # Ensure trap returns 0
}
trap cleanup EXIT

# 5) HELPER FUNCTIONS

format_size() {
  awk -v b="$1" 'BEGIN {
    split("B KB MB GB TB", units);
    u=1;
    while(b >= 1024 && u < 5) { b/=1024; u++ }
    printf "%.2f%s", b, units[u]
  }'
}

# Cross-platform file size in bytes. macOS uses -f %z, Linux uses -c %s.
get_file_size() {
  local f="$1"
  local size
  case "$OS_TYPE" in
    macos) size=$(stat -f %z "$f" 2>/dev/null) ;;
    *)     size=$(stat -c %s "$f" 2>/dev/null) ;;
  esac
  # Ensure we always return a number
  echo "${size:-0}"
}

print_tree() {
  local list_file="$1"
  sort "$list_file" | awk -v dir_col="$CLR_DIR" -v reset="$RESET" -v tree_col="$CLR_TREE" -F/ '
  {
    for (i=1; i<NF; i++) {
      if ($i != last[i]) {
        for (j=1; j<i; j++) printf tree_col "│   " reset
        if (i == 1) printf "" 
        else printf tree_col "├── " reset
        print dir_col $i "/" reset
        last[i] = $i
        for (k=i+1; k<=20; k++) delete last[k]
      }
    }
    for (j=1; j<NF; j++) printf tree_col "│   " reset
    printf tree_col "├── " reset
    print $NF
    delete last[NF]
  }'
}

print_help() {
  cat <<EOF
${BOLD}catclip${RESET} ${DIM}v${VERSION}${RESET} - Copy code context for AI prompts

  Recursively copies code files to your clipboard with a visual tree preview.
  Automatically filters out secrets, binaries, and build artifacts.
  Respects ${BOLD}.gitignore${RESET} and your ${BOLD}ignore list${RESET}.

${BOLD}Output Format:${RESET}
  Each file is prefixed with ${DIM}# File: path/to/file${RESET} so AI can see the structure.

${BOLD}Usage:${RESET}
  catclip [OPTIONS] [TARGETS...]

${BOLD}Targets:${RESET}
  ${BOLD}Fuzzy Directory Search:${RESET}
    ${CLR_SUCCESS}catclip authentication${RESET}          # Finds src/features/authentication (finds any directory matching 'authentication')
    ${CLR_SUCCESS}catclip components${RESET}              # Finds src/components, authentication/components, etc. (prompts if multiple)
  
  ${BOLD}Chained Path Resolution:${RESET}
    ${CLR_SUCCESS}catclip authentication/components/LoginForm.tsx${RESET}  # Resolves 'authentication' → 'components' → copies 'LoginForm.tsx'
    ${CLR_SUCCESS}catclip authentication/api${RESET}                       # Resolves 'authentication' → 'api' → copies directory contents

  ${BOLD}Full Relative Paths:${RESET}
    ${CLR_SUCCESS}catclip src/components/ui/Button.tsx${RESET}    # Fast. Use Tab completion from root (src/[TAB]/[TAB]...)
    ${CLR_SUCCESS}catclip src/config/constants.ts${RESET}         # Precise. Avoids ambiguity for common filenames
  
  ${BOLD}Files in Current Directory:${RESET}
    ${CLR_SUCCESS}catclip Dockerfile${RESET}              # File in current working directory
    ${CLR_SUCCESS}catclip vite.config.js tsconfig.json${RESET}  # Multiple files
  
  ${BOLD}Mixed Arguments:${RESET}
    ${CLR_SUCCESS}catclip README.md src/features/todos${RESET}
    # → Copies 'README.md' + entire 'todos' feature directory

  ${BOLD}Paths with Spaces:${RESET}
    ${CLR_SUCCESS}catclip "docs/User Guide.md"${RESET}  # Use quotes for paths with spaces

${BOLD}Options:${RESET}
  ${CLR_SUCCESS}--help, -h${RESET}
      Show this help message.

  ${CLR_SUCCESS}--version, -v${RESET}
      Show the installed version.

  ${CLR_SUCCESS}--no-ignore, -n${RESET}
      ${BOLD}Temporarily${RESET} bypass all ignore rules for this copy only.
      
      ${DIM}catclip --no-ignore dist${RESET}
      ${DIM}catclip --no-ignore .env.local${RESET}

  ${CLR_SUCCESS}--yes, -y${RESET}
      Skip confirmation prompt (useful for large copies or scripts).

  ${CLR_SUCCESS}--print, -p${RESET}
      Print to terminal in addition to copying to clipboard.

  ${CLR_SUCCESS}--list-ignores, -l${RESET}
      Show what files and directories are currently being ignored.

  ${CLR_SUCCESS}--no-tree, -t${RESET}
      Skip tree rendering for faster output on large file sets.

  ${CLR_SUCCESS}--ignore, -i [OPERATIONS]${RESET}
      Permanently modify your ignore list.
      
      ${BOLD}Add/remove files:${RESET}  +'pattern'  -'pattern'
      ${BOLD}Add/remove dirs:${RESET}   d+dirname  d-dirname
      ${DIM}Quote after +/- if it has spaces or globs:${RESET}
      ${DIM}  +'<pattern>'  -'*.ts'  d+'my dir'${RESET}
      
      ${DIM}catclip --ignore +'*.log' -'secret.json' d+build d-src${RESET}
      # → Ignores .log files, un-ignores secret.json
      # → Ignores 'build' directory, un-ignores 'src' directory
      ${DIM}catclip src --ignore +'main.tsx'${RESET}
      # → Temporarily ignores main.tsx for this run only
  
  ${CLR_SUCCESS}--reset-config, -r${RESET}
      Restore the configuration file to factory defaults.

${CLR_ERROR}Not Allowed:${RESET}
  catclip ../config                              # Cannot go above working directory
  catclip /absolute/path/to/file                 # Absolute paths are not allowed

${BOLD}Config Location:${RESET}
  ${DIM}$CONFIG${RESET}
EOF
}

# ------------------------------------------------------------------------------
# OPTIMIZED BINARY DETECTION
# ------------------------------------------------------------------------------
# Strategy: Check extensions first (fast), only use 'file --mime' as fallback.
# This avoids spawning a subprocess for every file. 10x faster on large repos.

# Cache mime results by extension to avoid repeated 'file' calls.
mime_cache_exts=()
mime_cache_vals=()

is_text_file() {
  local f="$1"
  local ext="${f##*.}"
  
  # ----------------------------------------------------------------------------
  # TIER 1: HARD BLOCKS (Return 1)
  # ----------------------------------------------------------------------------
  # Files that are technically unreadable (binary), dangerous to print (weights),
  # or effectively useless "token poison" (SVGs, Source Maps).
  #
  # Categories:
  #   1. Images (Raster & Vector) - SVG is here because path data is token poison
  #   2. Documents (Office & PDF are Zipped XMLs/Binaries)
  #   3. Archives & Disk Images
  #   4. Compiled Executables, Libraries & Debug Symbols
  #   5. Bytecode & Virtual Machine Artifacts
  #   6. Mobile & Package Installers
  #   7. AI Models & Large Data (CRITICAL protection against massive files)
  #   8. Audio & Video
  #   9. Fonts
  #   10. 3D & Design (Binary formats)
  #   11. Database, Generic Binary, & Developer Noise (map=Sourcemaps, lockb=Bun)
  case "$ext" in
    png|jpg|jpeg|gif|bmp|ico|svg|webp|tif|tiff|psd|xcf|heic|raw|\
pdf|docx|doc|xlsx|xls|pptx|ppt|odt|ods|odp|rtf|\
zip|tar|gz|bz2|xz|7z|rar|dmg|iso|img|vmdk|qcow2|\
exe|dll|so|dylib|a|lib|o|obj|pdb|\
class|jar|war|ear|pyc|pyo|pyd|wasm|beam|rlib|\
apk|aab|ipa|msi|cab|deb|rpm|\
pt|pth|ckpt|safetensors|onnx|gguf|h5|pkl|parquet|arrow|\
mp3|mp4|mov|avi|mkv|webm|flv|wmv|m4a|wav|flac|ogg|3gp|\
ttf|otf|woff|woff2|eot|\
blend|glb|fbx|3ds|\
db|sqlite|sqlite3|bin|dat|hex|dump|map|lockb)
      return 1
      ;;
  esac
  
  # ----------------------------------------------------------------------------
  # TIER 2: TEXT ALLOW LIST (Return 0)
  # ----------------------------------------------------------------------------
  # Files strictly defined as text. We list them here to bypass the slow
  # 'file --mime' check. This includes "Soft Blocks" like .lock or .xml
  # which are text but usually ignored via YAML config.
  #
  # Categories:
  #   1. Web & Markup
  #   2. Configuration & Data
  #   3. Documentation
  #   4. Scripting & Shell
  #   5. Compiled Languages (Source)
  #   6. Game Dev & Graphics Code
  #   7. Build Systems & CI/CD
  #   8. Project Files
  #   9. Niche / Functional / Scientific
  #   10. Data & Specialized Formats
  #   11. Modern Frameworks & Templates
  case "$ext" in
    html|htm|css|scss|sass|less|js|jsx|mjs|cjs|ts|tsx|mts|cts|\
json|yaml|yml|xml|toml|ini|cfg|conf|properties|env|lock|\
md|markdown|txt|text|rst|adoc|\
py|pyw|pyi|ipynb|rb|erb|haml|pl|pm|lua|sh|bash|zsh|fish|bat|cmd|ps1|psm1|psd1|\
c|cc|cpp|cxx|h|hh|hpp|hxx|go|rs|swift|kt|kts|scala|cs|fs|vb|vbs|java|jsp|php|sql|\
gd|godot|shader|unity|qml|\
makefile|Makefile|mk|cmake|gradle|jenkinsfile|Jenkinsfile|\
dockerfile|Dockerfile|groovy|gvy|tf|hcl|\
sln|csproj|vbproj|fsproj|\
r|R|rmd|clj|cljs|ex|exs|erl|hrl|elm|nim|zig|v|d|m|mm|\
hs|lhs|jl|cl|lisp|rkt|asm|s|\
csv|tsv|graphql|gql|proto|sol|patch|diff|\
vim|dart|vue|svelte|astro|tex|j2|ejs|hbs|mustache|liquid|pug|jade)
      return 0
      ;;
  esac
  
  # ----------------------------------------------------------------------------
  # TIER 3: SLOW FALLBACK
  # ----------------------------------------------------------------------------
  if [[ -n "$ext" ]]; then
    for i in "${!mime_cache_exts[@]}"; do
      if [[ "${mime_cache_exts[i]}" == "$ext" ]]; then
        [[ "${mime_cache_vals[i]}" == "text" ]] && return 0
        [[ "${mime_cache_vals[i]}" == "binary" ]] && return 1
      fi
    done
  fi

  local mime
  local result=1
  local cache_kind=""
  mime=$(file -b --mime "$f" 2>/dev/null)
  
  if [[ "$mime" =~ utf-16 ]] || [[ "$mime" =~ utf-32 ]] || [[ "$mime" =~ binary ]]; then
    result=1
    cache_kind="binary"
  elif [[ "$mime" == text/* ]] || [[ "$mime" =~ application/json ]] || [[ "$mime" =~ application/xml ]] || \
       [[ "$mime" =~ application/javascript ]] || [[ "$mime" =~ application/x-sh ]] || [[ "$mime" =~ application/x-yaml ]]; then
    result=0
    cache_kind="text"
  elif [[ ! -s "$f" ]]; then
    result=0
    cache_kind="text"
  fi

  if [[ -n "$cache_kind" && -n "$ext" ]]; then
    mime_cache_exts+=( "$ext" )
    mime_cache_vals+=( "$cache_kind" )
  fi

  return "$result"
}

# Prompt for y/n with a default without failing in non-interactive contexts.
# Sets PROMPT_RESPONSE to "y" or "n" (lowercase).
# ------------------------------------------------------------------------------
# PATH RESOLUTION HELPERS
# ------------------------------------------------------------------------------

# SECURITY: Block parent traversal (../) to prevent copying outside project.
contains_parent_traversal() {
  local path="$1"
  [[ "$path" == *../* || "$path" == ../* || "$path" == *.. ]]
}

is_absolute_path() {
  local path="$1"
  [[ "$path" == /* ]]
}

has_slashes() {
  [[ "$1" == */* ]]
}

# Fuzzy search for directories matching *pattern* anywhere in the tree.
# Optional base_dir scopes the search. Uses indexed arrays for Bash 3.2 compat.
fuzzy_search_dir() {
  local search_name="$1"
  local base_dir="${2:-.}"  # Default to current directory if not specified
  local found=()
  
  local search_prune_opts=()
  if [[ "$NO_IGNORE" == false ]] && (( ${#ignore_dirs[@]} > 0 )); then
    for d in "${ignore_dirs[@]}"; do 
      search_prune_opts+=( -name "$d" -prune -o )
    done
  fi

  local find_cmd_opts=()
  if (( ${#search_prune_opts[@]} > 0 )); then
    find_cmd_opts=( "${search_prune_opts[@]}" )
  fi
  find_cmd_opts+=( -type d -name "*${search_name}*" -print0 )

  while IFS= read -r -d '' d; do 
    if [[ "$IS_GIT" == true && "$NO_IGNORE" == false ]]; then
      if git check-ignore -q "$d" 2>/dev/null; then 
        continue
      fi
    fi
    found+=( "$d" )
  done < <(find "$base_dir" "${find_cmd_opts[@]}" 2>/dev/null)
  
  if (( ${#found[@]} == 0 )); then
    return 1
  elif (( ${#found[@]} == 1 )); then
    echo "${found[0]}"
    return 0
  else
    local context_msg="'$search_name'"
    [[ "$base_dir" != "." ]] && context_msg="'$search_name' in ${CLR_DIR}$base_dir${RESET}"
    printf "%s\n" "${BOLD}Multiple matches for $context_msg:${RESET}" >&2
    for i in "${!found[@]}"; do 
      printf "  ${BOLD}%2d)${RESET} ${CLR_DIR}%s${RESET}\n" $((i+1)) "${found[i]}" >&2
    done
    if (( ${#found[@]} > 5 )); then
      printf "%s\n" "${CLR_WARN}Tip:${RESET} ${DIM}Too many matches. Narrow it with exact parents like 'parent/${search_name}' or 'parent_of_parent/parent/${search_name}'.${RESET}" >&2
    fi
    read -rp "Choose [1-${#found[@]}]: " c
    if [[ "$c" =~ ^[0-9]+$ ]] && (( c >= 1 && c <= ${#found[@]} )); then
      echo "${found[c-1]}"
      return 0
    else
      printf "%s\n" "${CLR_ERROR}Invalid selection.${RESET}" >&2
      exit 2
    fi
  fi
}

# Resolve a chained path like "accessibility/browser/file.ts"
# Returns the resolved directory path (without filename)
# Usage: resolve_chained_path "dir1/dir2/dir3" -> resolved_path
resolve_chained_path() {
  local path_segments="$1"
  local current_base="."
  local segments=()
  
  # Split path by /
  IFS='/' read -ra segments <<< "$path_segments"
  
  for segment in "${segments[@]}"; do
    # First check if exact subdirectory exists
    if [[ -d "$current_base/$segment" ]]; then
      current_base="$current_base/$segment"
    else
      # Fuzzy search within current base (using unified function with base_dir)
      if resolved=$(fuzzy_search_dir "$segment" "$current_base"); then
        current_base="$resolved"
      else
        local ret=$?
        if (( ret == 2 )); then exit 2; fi
        
        printf "%s\n" "${CLR_ERROR}Error: No directory matching '$segment' found in $current_base${RESET}" >&2
        return 1
      fi
    fi
  done
  
  echo "$current_base"
  return 0
}

check_file_ignore() {
  local filename="$1"
  
  if [[ "$NO_IGNORE" == true ]]; then
    return 1
  fi
  
  for pat in "${ignore_files[@]:-}"; do
    if [[ "$filename" == $pat ]]; then
      return 0
    fi
  done
  
  return 1
}

# ------------------------------------------------------------------------------
# IGNORE CHECKING
# ------------------------------------------------------------------------------
# Two ignore sources: YAML config (global) + .gitignore (project-specific).
# IGNORE_REASON tracks which source matched, for better error messages.

# Returns 0 if ignored, 1 if allowed. Sets IGNORE_REASON to "yaml" or "gitignore".
# Returns 0 if ignored by YAML config only.
is_dir_ignored_yaml() {
  local dirname="$1"
  if [[ "$NO_IGNORE" == true ]]; then return 1; fi
  if (( ${#ignore_dirs[@]} > 0 )); then
    for d in "${ignore_dirs[@]}"; do
      if [[ "$dirname" == "$d" ]]; then return 0; fi
    done
  fi
  return 1
}

# Returns 0 if ignored, 1 if allowed. Sets IGNORE_REASON.
is_dir_ignored() {
  local dirpath="$1"
  local dirname
  dirname=$(basename "$dirpath")
  IGNORE_REASON=""
  
  if [[ "$NO_IGNORE" == true ]]; then
    return 1
  fi
  
  # Check YAML config first
  if is_dir_ignored_yaml "$dirname"; then
    IGNORE_REASON="yaml"
    return 0
  fi
  
  # Check git ignore if in git repo
  if [[ "$IS_GIT" == true ]]; then
    if git check-ignore -q "$dirpath" 2>/dev/null; then
      IGNORE_REASON="gitignore"
      return 0
    fi
  fi
  
  return 1
}

# Print standardized "directory is ignored" error/warning message
# Usage: print_dir_ignore_msg <dir_name> ["error"|"warning"]
print_dir_ignore_msg() {
  local dir_name="$1"
  local msg_type="${2:-error}"
  
  local prefix action suffix
  if [[ "$msg_type" == "warning" ]]; then
    prefix="${CLR_WARN}Warning:"
    action="but proceeding with explicit path."
  else
    prefix="${CLR_ERROR}Error:"
    action=""
    suffix="\n${DIM}Use --no-ignore to include it anyway.${RESET}"
  fi
  
  if [[ "$IGNORE_REASON" == "yaml" ]]; then
    printf "%s Directory '%s' is in ignore list%s${RESET}" "$prefix" "$dir_name" "${action:+, $action}" >&2
  else
    printf "%s Directory '%s' is ignored by .gitignore%s${RESET}" "$prefix" "$dir_name" "${action:+, $action}" >&2
  fi
  echo >&2
  
  [[ "$msg_type" == "error" ]] && printf "${DIM}Use --no-ignore to include it anyway.${RESET}\n" >&2
  return 0
}

extract_dir_components() {
  local path="$1"
  local dir_part="${path%/*}"
  
  if [[ "$dir_part" == "$path" ]]; then
    return
  fi
  
  IFS='/' read -ra components <<< "$dir_part"
  for comp in "${components[@]}"; do
    echo "$comp"
  done
}

# Traverse up the path to check if any parent directory is ignored
# Traverse up the path to check if any parent directory is ignored
check_parent_ignores() {
  local path="$1"
  local current_dir
  current_dir=$(dirname "$path")
  
  # 1. OPTIMIZATION: Check YAML ignores in loop (fast, pure Bash)
  while [[ "$current_dir" != "." && "$current_dir" != "/" && -n "$current_dir" ]]; do
    if is_dir_ignored_yaml "$(basename "$current_dir")"; then
      IGNORE_REASON="yaml"
      print_dir_ignore_msg "$(basename "$current_dir")" "warning"
      return 0
    fi
    current_dir=$(dirname "$current_dir")
  done
  
  # 2. OPTIMIZATION: Check Git ignores ONCE on the full path (slow, spawns process)
  # git check-ignore handles recursive parent checks natively.
  if [[ "$IS_GIT" == true && "$NO_IGNORE" == false ]]; then
    # If the path matches a gitignore rule, we need to determine WHICH directory is ignored
    # to provide a helpful warning. We scan up the tree to find the culprit.
    if git check-ignore -q "$path" 2>/dev/null; then
       
       local check_dir=$(dirname "$path")
       while [[ "$check_dir" != "." && "$check_dir" != "/" && -n "$check_dir" ]]; do
         if git check-ignore -q "$check_dir" 2>/dev/null; then
             IGNORE_REASON="gitignore"
             print_dir_ignore_msg "$(basename "$check_dir")" "warning"
             return 0
         fi
         check_dir=$(dirname "$check_dir")
       done
    fi
  fi
  
  return 0
}

# 6) FLAG PARSING
SKIP_CONFIRM=false
NO_IGNORE=false
LIST_IGNORES=false
SHOW_HELP=false
SHOW_VERSION=false
PRINT_CONTENT=false
RESET_CONFIG=false
NO_TREE=false
IGNORE_OPS=()
raw_inputs=()

while (( $# )); do
  case "$1" in
    --yes|-y)       SKIP_CONFIRM=true;    shift ;;
    --no-ignore|-n) NO_IGNORE=true;       shift ;;
    --list-ignores|-l) LIST_IGNORES=true; shift ;;
    --print|-p)     PRINT_CONTENT=true;   shift ;;
    --reset-config|-r) RESET_CONFIG=true; shift ;;
    --no-tree|-t)   NO_TREE=true;         shift ;;
    --help|-h)      SHOW_HELP=true;       shift ;;
    --version|-v)   SHOW_VERSION=true;    shift ;;
    --ignore|-i)
      shift
      [[ $# -eq 0 ]] && { printf "%s\n" "${CLR_ERROR}Error: --ignore requires arguments.${RESET}" >&2; exit 1; }
      while (( $# )) && [[ $1 =~ ^(d?[+-]) ]]; do
        IGNORE_OPS+=( "$1" )
        shift
      done
      ;;
    --) shift; raw_inputs+=( "$@" ); break ;;
    --*) 
      printf "%s\n" "${CLR_ERROR}Error: Unknown option '$1'${RESET}" >&2
      printf "Try '${CLR_SUCCESS}catclip${RESET} --help' for available options.\n" >&2
      exit 1
      ;;
    *)   raw_inputs+=( "$1" ); shift ;;
  esac
done

[[ "$SHOW_HELP" == true ]] && { print_help; exit 0; }
[[ "$SHOW_VERSION" == true ]] && { echo "catclip $VERSION"; exit 0; }

if [[ "$RESET_CONFIG" == true ]]; then
  echo "${CLR_WARN}This will overwrite ${BOLD}$CONFIG${RESET}${CLR_WARN} with factory defaults.${RESET}" >&2
  prompt_yn "Are you sure? [y/N] " "n"
  if [[ "$PROMPT_RESPONSE" == "y" ]]; then
    get_default_config > "$CONFIG"
    echo "${CLR_SUCCESS}Configuration restored.${RESET}" >&2
  else
    echo "Cancelled." >&2
  fi
  exit 0
fi

# 7) LOAD IGNORES
ignore_dirs=()
ignore_files=()
parse_error=false
error_msg=""

if [[ -r "$CONFIG" ]]; then
  while IFS='|' read -r type value; do
    if [[ "$type" == "ERR" ]]; then
      parse_error=true
      error_msg="$value"
      break
    elif [[ "$type" == "D" ]]; then
      ignore_dirs+=( "$value" )
    elif [[ "$type" == "F" ]]; then
      ignore_files+=( "$value" )
    fi
  done < <(awk '
    { raw = $0; sub(/#.*/, ""); gsub(/^[ \t]+|[ \t]+$/, ""); }
    length($0) == 0 { next }
    /^ignore_dirs:/  { block="D"; next }
    /^ignore_files:/ { block="F"; next }
    /^- / {
      if (block == "") { print "ERR|Orphaned item: " raw; exit 1 }
      sub(/^- /, ""); gsub(/^["\x27]|["\x27]$/, "");
      if (block == "D") print "D|" $0;
      if (block == "F") print "F|" $0;
      next
    }
    { print "ERR|Syntax error: " raw; exit 1 }
  ' "$CONFIG")
fi

if [[ "$parse_error" == true ]]; then
  printf "\n%s\n" "${CLR_ERROR}Config Corrupted in ${BOLD}$CONFIG${RESET}" >&2
  printf "%s\n" "${CLR_ERROR}➤ $error_msg${RESET}" >&2
  prompt_yn "\n${CLR_WARN}Would you like to reset to factory defaults? [y/N]${RESET} " "n"
  if [[ "$PROMPT_RESPONSE" == "y" ]]; then
    get_default_config > "$CONFIG"
    echo "${CLR_SUCCESS}Configuration reset. Retrying...${RESET}" >&2
    exec "$0" "$@"
  else
    echo "${CLR_ERROR}Aborting. Please fix the file manually.${RESET}" >&2
    exit 1
  fi
fi

# Check for empty config (both arrays empty = likely broken/cleared config)
if (( ${#ignore_dirs[@]} == 0 && ${#ignore_files[@]} == 0 )); then
  printf "\n%s\n" "${CLR_WARN}Config Empty in ${BOLD}$CONFIG${RESET}" >&2
  printf "%s\n" "${DIM}No ignore rules defined. This may cause unexpected behavior.${RESET}" >&2
  prompt_yn "\n${CLR_WARN}Would you like to reset to factory defaults? [y/N]${RESET} " "n"
  if [[ "$PROMPT_RESPONSE" == "y" ]]; then
    get_default_config > "$CONFIG"
    echo "${CLR_SUCCESS}Configuration reset. Retrying...${RESET}" >&2
    exec "$0" "$@"
  else
    echo "${CLR_WARN}Continuing with empty config...${RESET}" >&2
  fi
fi


# 8) CONFIG UPDATE LOGIC
apply_ignore_ops() {
  changes_log=()
  added_files=()
  removed_files=()
  added_dirs=()
  removed_dirs=()

  for op in "${IGNORE_OPS[@]}"; do
    case "$op" in
      d+*)
           dir_name="${op:2}"
           ignore_dirs+=( "$dir_name" )
           added_dirs+=( "$dir_name" )
           changes_log+=( "${CLR_SUCCESS}+${RESET} ${CLR_DIR}${dir_name}${RESET}" )
           ;;
      d-*)
           new_dirs=()
           for d in "${ignore_dirs[@]}"; do [[ "$d" != "${op:2}" ]] && new_dirs+=("$d"); done
           ignore_dirs=("${new_dirs[@]}")
           removed_dirs+=( "${op:2}" )
           changes_log+=( "${CLR_ERROR}-${RESET} ${CLR_DIR}${op:2}${RESET}" )
           ;;
      +*)
           file_pattern="${op:1}"
           ignore_files+=( "$file_pattern" )
           added_files+=( "$file_pattern" )
           changes_log+=( "${CLR_SUCCESS}+${RESET} ${file_pattern}" )
           ;;
      -*)
           new_files=()
           for f in "${ignore_files[@]}"; do [[ "$f" != "${op:1}" ]] && new_files+=("$f"); done
           ignore_files=("${new_files[@]}")
           removed_files+=( "${op:1}" )
           changes_log+=( "${CLR_ERROR}-${RESET} ${op:1}" )
           ;;
    esac
  done
}

if (( ${#IGNORE_OPS[@]} > 0 )); then
  if (( ${#raw_inputs[@]} > 0 )); then
    printf "%s\n" "${BOLD}${CLR_WARN}Temporary ignore (this run):${RESET}" >&2
    apply_ignore_ops
    if (( ${#added_files[@]} > 0 )); then
      printf "${BOLD}Ignored files:${RESET}\n" >&2
      for f in "${added_files[@]}"; do printf "  ${CLR_WARN}•${RESET} %s\n" "$f" >&2; done
    fi
    if (( ${#added_dirs[@]} > 0 )); then
      printf "${BOLD}Ignored directories:${RESET}\n" >&2
      for d in "${added_dirs[@]}"; do printf "  ${CLR_ERROR}•${RESET} ${CLR_DIR}%s${RESET}\n" "$d" >&2; done
    fi
    if (( ${#removed_files[@]} > 0 )); then
      printf "${BOLD}Unignored files:${RESET}\n" >&2
      for f in "${removed_files[@]}"; do printf "  ${CLR_SUCCESS}•${RESET} %s\n" "$f" >&2; done
    fi
    if (( ${#removed_dirs[@]} > 0 )); then
      printf "${BOLD}Unignored directories:${RESET}\n" >&2
      for d in "${removed_dirs[@]}"; do printf "  ${CLR_SUCCESS}•${RESET} ${CLR_DIR}%s${RESET}\n" "$d" >&2; done
    fi
  else
    printf "%s\n" "${BOLD}Updating ignore list in ${DIM}$CONFIG${RESET}" >&2
    apply_ignore_ops

    {
      echo "ignore_dirs:"
      for d in "${ignore_dirs[@]}"; do echo "  - $d"; done
      echo "ignore_files:"
      for f in "${ignore_files[@]}"; do echo "  - \"$f\""; done
    } >"$CONFIG"

    printf "\n${BOLD}New Configuration:${RESET}\n" >&2
    printf "\n${BOLD}Ignored Directories (YAML):${RESET}\n" >&2
    for d in "${ignore_dirs[@]}"; do printf "  ${CLR_ERROR}•${RESET} ${CLR_DIR}%s${RESET}\n" "$d" >&2; done
    printf "\n${BOLD}Ignored Files (YAML):${RESET}\n" >&2
    for f in "${ignore_files[@]}"; do printf "  ${CLR_WARN}•${RESET} %s\n" "$f" >&2; done

    printf "\n${BOLD}Changes applied:${RESET}\n" >&2
    for change in "${changes_log[@]}"; do printf "  %s\n" "$change" >&2; done

    if [[ "$HAS_GIT" == true ]] && git rev-parse --show-toplevel &>/dev/null; then
      printf "\n${CLR_GIT}Note: Files listed in .gitignore remain excluded automatically.${RESET}\n" >&2
    else
      printf "\n${DIM}Note: If used inside a Git project, .gitignore rules will also apply.${RESET}\n" >&2
    fi
    exit 0
  fi
fi

# 9) LIST IGNORES COMMAND
if [[ "$LIST_IGNORES" == true ]]; then
  printf "%s\n" "${BOLD}Current Configuration${RESET}" >&2
  printf "${DIM}%s${RESET}\n" "$CONFIG" >&2
  
  printf "\n${BOLD}Ignored Directories (YAML):${RESET}\n" >&2
  for d in "${ignore_dirs[@]:-}"; do printf "  ${CLR_ERROR}•${RESET} ${CLR_DIR}%s${RESET}\n" "$d" >&2; done
  
  printf "\n${BOLD}Ignored Files (YAML):${RESET}\n" >&2
  for f in "${ignore_files[@]:-}"; do printf "  ${CLR_WARN}•${RESET} %s\n" "$f" >&2; done

  if [[ "$HAS_GIT" == true ]] && git rev-parse --show-toplevel &>/dev/null; then
    git_root=$(git rev-parse --show-toplevel)
    git_ignore_file="$git_root/.gitignore"
    if [[ -f "$git_ignore_file" ]]; then
      printf "\n${BOLD}Ignored Files (Project .gitignore):${RESET}\n" >&2
      printf "${DIM}%s${RESET}\n" "$git_ignore_file" >&2
      grep -vE '^\s*#|^\s*$' "$git_ignore_file" | while read -r line; do
        printf "  ${CLR_GIT}•${RESET} %s\n" "$line" >&2
      done
    else
      printf "\n${DIM}(No .gitignore found in project root)${RESET}\n" >&2  
    fi
  fi
  exit 0
fi

# 10) TARGET RESOLUTION (NEW SMART PATH RESOLUTION)
(( ${#raw_inputs[@]} == 0 )) && raw_inputs=( "." )

IS_GIT=false
if [[ "$HAS_GIT" == true ]] && git rev-parse --show-toplevel &>/dev/null 2>&1; then IS_GIT=true; fi

file_targets=()
dir_targets=()

for arg in "${raw_inputs[@]}"; do
  
  if contains_parent_traversal "$arg"; then
    printf "%s\n" "${CLR_ERROR}Error: Cannot traverse above working directory: '$arg'${RESET}" >&2
    printf "${DIM}Hint: catclip must be run from project root and cannot access parent directories.${RESET}\n" >&2
    exit 1
  fi

  if is_absolute_path "$arg"; then
    printf "%s\n" "${CLR_ERROR}Error: Absolute paths are not allowed: '$arg'${RESET}" >&2
    printf "${DIM}Hint: Use a relative path from the project root.${RESET}\n" >&2
    exit 1
  fi
  
  # BRANCH 1: Single word (no slashes) - local file/dir or fuzzy search
  if ! has_slashes "$arg"; then
    if [[ -d "$arg" ]]; then
      # Local directory exists - check if ignored
      if is_dir_ignored "./$arg"; then
        print_dir_ignore_msg "$arg" "error"
        exit 1
      fi
      dir_targets+=( "./$arg" )
      
      elif resolved_dir=$(fuzzy_search_dir "$arg"); then
      # Found matching directories via fuzzy search
      if is_dir_ignored "$resolved_dir"; then
        resolved_name=$(basename "$resolved_dir")
        print_dir_ignore_msg "$resolved_name" "error"
        exit 1
      fi
      dir_targets+=( "$resolved_dir" )
      
    else
      # Check exit code of fuzzy search (it runs in subshell for command substitution)
      # But since we used 'elif', we lost the exit code? No, 'elif command' failure exit status is available?
      # Actually, clean way is to re-check if we need to abort.
      # Bash behavior: if the condition failed, $? holds the return code.
      ret=$?
       if (( ret == 2 )); then exit 2; fi
       
       if [[ -f "$arg" ]]; then
        # Local file exists (only match if no directory found)
        if check_file_ignore "$arg"; then
          printf "%s\n" "${CLR_ERROR}Error: File '$arg' is ignored by pattern.${RESET}" >&2
          printf "${DIM}Use --no-ignore to include it anyway.${RESET}\n" >&2
          exit 1
        fi
        file_targets+=( "./$arg" )
      
      elif [[ "$arg" == *.* ]]; then
      # Looks like a filename but not found
      printf "%s\n" "${CLR_ERROR}Error: File '$arg' not found in working directory.${RESET}" >&2
      printf "\n${DIM}Hint: For files outside working directory, use:${RESET}\n" >&2
      printf "  ${CLR_SUCCESS}directory/filename${RESET}       ${DIM}(fuzzy search directory first)${RESET}\n" >&2
      printf "  ${CLR_SUCCESS}full/path/to/file${RESET}        ${DIM}(relative path from root)${RESET}\n" >&2
      exit 1
      
    else
      # No directory found, not a file
      printf "%s\n" "${CLR_ERROR}Error: No directory matching '$arg' found.${RESET}" >&2
      printf "\n${DIM}Searched for directories containing '%s' in their name.${RESET}\n" "$arg" >&2
      printf "\n${DIM}Try:${RESET}\n" >&2
      printf "  ${CLR_SUCCESS}catclip .${RESET}                ${DIM}(copy current directory)${RESET}\n" >&2
      printf "  ${CLR_SUCCESS}catclip src${RESET}              ${DIM}(fuzzy match 'src' directory)${RESET}\n" >&2
      exit 1
    fi
    fi
    
  # BRANCH 2: Has slashes - path resolution (exact or chained)
  else
    filename="${arg##*/}"
    dir_path="${arg%/*}"
    
    # First check if exact path already exists
    if [[ -e "$arg" ]]; then
      # Exact path exists - use it directly
      if [[ -f "$arg" ]]; then
        if check_file_ignore "$filename"; then
          printf "%s\n" "${CLR_ERROR}Error: File '$filename' is ignored by pattern.${RESET}" >&2
          printf "${DIM}Use --no-ignore to include it anyway.${RESET}\n" >&2
          exit 1
        fi
        
        # Check if parent directory is ignored
        check_parent_ignores "$arg"
        
        if ! is_text_file "$arg"; then
          printf "%s\n" "${CLR_ERROR}Error: File '$filename' is a binary file and cannot be copied.${RESET}" >&2
          exit 1
        fi
        file_targets+=( "$arg" )
        
      elif [[ -d "$arg" ]]; then
        dirname_base=$(basename "$arg")
        if is_dir_ignored "$arg"; then
          print_dir_ignore_msg "$dirname_base" "warning"
        fi
        dir_targets+=( "$arg" )
      fi
      
    else
      # Path doesn't exist - use chained resolution
      if ! resolved_dir=$(resolve_chained_path "$dir_path"); then
        exit 1
      fi
      
      full_path="$resolved_dir/$filename"
      
      if [[ -d "$full_path" ]]; then
        if is_dir_ignored "$full_path"; then
          resolved_name=$(basename "$full_path")
          print_dir_ignore_msg "$resolved_name" "error"
          exit 1
        fi
        dir_targets+=( "$full_path" )
        
      elif [[ -f "$full_path" ]]; then
        # Check if parent directory is ignored (using recursive check)
        check_parent_ignores "$full_path"
        
        if ! is_text_file "$full_path"; then
          printf "%s\n" "${CLR_ERROR}Error: File '$filename' is a binary file and cannot be copied.${RESET}" >&2
          exit 1
        fi
        if check_file_ignore "$filename"; then
          printf "%s\n" "${CLR_ERROR}Error: File '$filename' is ignored by pattern.${RESET}" >&2
          printf "${DIM}Use --no-ignore to include it anyway.${RESET}\n" >&2
          exit 1
        fi
        file_targets+=( "$full_path" )
        
      else
        printf "%s\n" "${CLR_ERROR}Error: '$filename' not found in directory '$resolved_dir'${RESET}" >&2
        printf "${DIM}Searched in: $full_path${RESET}\n" >&2
        exit 1
      fi
    fi
  fi
done

if (( ${#file_targets[@]} == 0 && ${#dir_targets[@]} == 0 )); then
  printf "%s\n" "${CLR_ERROR}Error: No valid targets specified.${RESET}" >&2
  exit 1
fi

# 11) BUILD FALLBACK COMMANDS
find_opts=()
if [[ "$NO_IGNORE" == false ]] && (( ${#ignore_dirs[@]} > 0 )); then
  for d in "${ignore_dirs[@]}"; do find_opts+=( -name "$d" -prune -o ); done
fi
find_opts+=( -type f )
find_opts+=( -print0 )

# 12) PHASE 1: DISCOVERY
LISTFILE="$(mktemp)"
count=0

printf "\n${BOLD}Discovering files...${RESET}\n\n" >&2

# PHASE 1A: Process individual files
if (( ${#file_targets[@]} > 0 )); then
  for f in "${file_targets[@]}"; do
    if [[ ! -r "$f" ]]; then
      printf "${CLR_WARN}Warning: Cannot read file '%s'. Skipping.${RESET}\n" "$f" >&2
      continue
    fi
    if is_text_file "$f"; then
      normalized="${f#./}"
      echo "$normalized" >> "$LISTFILE"
      ((++count))
      if (( count % 100 == 0 )); then
      printf "${CLR_LABEL}[%d]${RESET} ${DIM}%s${RESET}\n" "$count" "$normalized" >&2
      fi
    fi
  done
fi

# PHASE 1B: Process directories
if [[ "$IS_GIT" == true && "$NO_IGNORE" == false ]] && (( ${#dir_targets[@]} > 0 )); then
  # GIT MODE
  # GIT MODE
  for tgt in "${dir_targets[@]}"; do
    # Check if this target belongs to a DIFFERENT git root (nested repo)
    # We resolve the absolute path to be sure
    abs_tgt=$(cd "$tgt" && pwd -P)
    tgt_git_root=$(git -C "$abs_tgt" rev-parse --show-toplevel 2>/dev/null || echo "")
    
    # Calculate relation to current root
    current_git_root=$(git rev-parse --show-toplevel 2>/dev/null || echo "")
    
    # Defaults for standard intra-repo behavior
    git_cmd=(git ls-files --cached --others --exclude-standard "$tgt")
    is_nested=false
    
    if [[ -n "$tgt_git_root" && "$tgt_git_root" != "$current_git_root" ]]; then
      # NESTED REPO DETECTED
      is_nested=true
      
      # Run ls-files INSIDE the nested repo.
      # git -C "$tgt" ls-files lists files relative to "$tgt".
      # We will prefix "$tgt/" to each line in the loop below to make it relative to CWD.
      git_cmd=(git -C "$tgt" ls-files --cached --others --exclude-standard)
    fi

    while IFS= read -r line; do
       if [[ "$is_nested" == true ]]; then
         # Prefix with the target directory to make it relative to CWD
         # Ensure clean path joining
         f="${tgt%/}/$line"
       else
         f="$line"
       fi
       
       filename="${f##*/}"
       skip=false
       if (( ${#ignore_files[@]} > 0 )); then
         for pat in "${ignore_files[@]}"; do
           if [[ "$filename" == $pat ]]; then skip=true; break; fi
         done
       fi
       
       if [[ "$skip" == false && "$NO_IGNORE" == false ]] && (( ${#ignore_dirs[@]} > 0 )); then
         # Calculate path relative to the target directory
         # This ensures that if we explicitly targeted an ignored directory (e.g. 'dist'),
         # we don't immediately filter out its contents.
         
         clean_tgt="${tgt#./}"
         clean_tgt="${clean_tgt%/}"
         rel_path="$f"
         
         if [[ "$clean_tgt" != "." && "$f" == "$clean_tgt/"* ]]; then
           rel_path="${f#$clean_tgt/}"
         fi

         for d in "${ignore_dirs[@]}"; do
           # Check if the relative path contains the ignored directory
           if [[ "$rel_path" == *"/$d/"* || "$rel_path" == "$d/"* ]]; then
             skip=true
             break
           fi
         done
       fi
       
       [[ "$skip" == true ]] && continue

       [[ -f "$f" ]] || continue
       if [[ ! -r "$f" ]]; then
         printf "${CLR_WARN}Warning: Cannot read file '%s'. Skipping.${RESET}\n" "$f" >&2
         continue
       fi
       
       if is_text_file "$f"; then
         echo "$f" >> "$LISTFILE"
         ((++count))
                   if (( count % 100 == 0 )); then
           printf "${CLR_LABEL}[%d]${RESET} ${DIM}%s${RESET}\n" "$count" "$f" >&2
         fi
       fi
    done < <("${git_cmd[@]}")
  done
elif (( ${#dir_targets[@]} > 0 )); then
  # FALLBACK MODE (FIND)
  for tgt in "${dir_targets[@]}"; do
    if (( ${#find_opts[@]} > 0 )); then
      while IFS= read -r -d '' f; do
        if [[ "$NO_IGNORE" == false ]] && (( ${#ignore_files[@]} > 0 )); then
          filename="${f##*/}"
          skip=false
          for pat in "${ignore_files[@]}"; do
             if [[ "$filename" == $pat ]]; then skip=true; break; fi
          done
          [[ "$skip" == true ]] && continue
    fi

        if [[ ! -r "$f" ]]; then
          printf "${CLR_WARN}Warning: Cannot read file '%s'. Skipping.${RESET}\n" "$f" >&2
          continue
        fi
        if is_text_file "$f"; then
          echo "${f#./}" >> "$LISTFILE"
          ((++count))
          if (( count % 100 == 0 )); then
            printf "${CLR_LABEL}[%d]${RESET} ${DIM}%s${RESET}\n" "$count" "${f#./}" >&2
          fi
        fi
      done < <(find "$tgt" "${find_opts[@]}")
    else
      while IFS= read -r -d '' f; do
        if [[ "$NO_IGNORE" == false ]] && (( ${#ignore_files[@]} > 0 )); then
          filename="${f##*/}"
          skip=false
          for pat in "${ignore_files[@]}"; do
             if [[ "$filename" == $pat ]]; then skip=true; break; fi
          done
          [[ "$skip" == true ]] && continue
        fi
        
        if [[ ! -r "$f" ]]; then
          printf "${CLR_WARN}Warning: Cannot read file '%s'. Skipping.${RESET}\n" "$f" >&2
          continue
        fi
        if is_text_file "$f"; then
          echo "${f#./}" >> "$LISTFILE"
          ((++count))
          if (( count % 100 == 0 )); then
            printf "${CLR_LABEL}[%d]${RESET} ${DIM}%s${RESET}\n" "$count" "${f#./}" >&2
          fi
        fi
      done < <(find "$tgt" -type f -print0)
    fi
  done
fi

if [[ ! -s "$LISTFILE" ]]; then
  printf "%s\n" "${CLR_WARN}No text files found.${RESET}" >&2
  exit 1
fi

# 13) PHASE 2: PREVIEW & ANALYSIS
total_bytes=0
if [[ -s "$LISTFILE" ]]; then
  # Batch stat for speed; fall back to per-file if needed.
  if [[ "$OS_TYPE" == "macos" ]]; then
    total_bytes=$(tr '\n' '\0' < "$LISTFILE" \
      | xargs -0 stat -f %z 2>/dev/null \
      | awk '{s+=$1} END {print s+0}' || echo 0)
  else
    total_bytes=$(tr '\n' '\0' < "$LISTFILE" \
      | xargs -0 stat -c %s 2>/dev/null \
      | awk '{s+=$1} END {print s+0}' || echo 0)
  fi

  if [[ ! "$total_bytes" =~ ^[0-9]+$ ]]; then
    total_bytes=0
  while IFS= read -r f; do
    size=$(get_file_size "./$f")
    [[ "$size" =~ ^[0-9]+$ ]] || size=0
    total_bytes=$((total_bytes + size))
  done < "$LISTFILE"
  fi
fi

total_bytes=$((total_bytes + (count * 30)))
human_size=$(format_size "$total_bytes")

est_tokens=$((total_bytes / 4))
TOKEN_WARN_LIMIT=32000

printf "\n${BOLD}Files to Copy:${RESET}\n" >&2

if [[ "$NO_IGNORE" == true ]]; then
  printf "  ${CLR_WARN}⚠️  Filters DISABLED (--no-ignore)${RESET}\n" >&2
elif [[ "$IS_GIT" == true ]]; then
  printf "  ${CLR_GIT}Excluding files in both .gitignore and %s${RESET}\n" "$CONFIG" >&2
elif [[ "$HAS_GIT" == false ]]; then
  printf "  ${CLR_WARN}git not installed, only excluding files in %s${RESET}\n" "$CONFIG" >&2
else
  printf "  ${CLR_WARN}Not a git repo, only excluding files in %s${RESET}\n" "$CONFIG" >&2
fi

if [[ "$NO_TREE" == false ]]; then
print_tree "$LISTFILE" >&2
fi
printf "\n" >&2

if (( est_tokens > TOKEN_WARN_LIMIT )); then
  printf "  ${CLR_WARN}⚠️  Warning: ~%d tokens. This may exceed the context window of some LLMs.%s\n" "$est_tokens" "${RESET}" >&2
fi

printf "  ${CLR_LABEL}%-8s${RESET} ${CLR_VALUE}%d files${RESET}\n" "Count:" "$count" >&2
printf "  ${CLR_LABEL}%-8s${RESET} ${CLR_VALUE}%s${RESET}\n" "Size:" "$human_size" >&2
printf "  ${CLR_LABEL}%-8s${RESET} ${CLR_VALUE}~%d${RESET}\n" "Tokens:" "$est_tokens" >&2

# 14) AUTO-CONFIRMATION LOGIC
if [[ "$SKIP_CONFIRM" == false && $est_tokens -gt $TOKEN_WARN_LIMIT ]]; then
  prompt_yn "${CLR_PROMPT}Proceed with copy? [y/N] ${RESET}" "n"
  if [[ "$PROMPT_RESPONSE" != "y" ]]; then
    printf "${CLR_WARN}Aborted.${RESET}\n" >&2
    exit 0
  fi
fi

# 14.5) CLIPBOARD DETECTION (late)
CLIPBOARD_CMD=""
USE_CLIPBOARD=true
if ! CLIPBOARD_CMD="$(detect_clipboard_cmd)"; then
  if [[ "$PRINT_CONTENT" == true ]]; then
    USE_CLIPBOARD=false
    printf "${CLR_WARN}Warning: No clipboard tool found. Printing to stdout only.${RESET}\n" >&2
  else
    echo "Error: No clipboard tool found." >&2
    case "$OS_TYPE" in
      macos) echo "  Install Xcode command line tools or ensure pbcopy is in PATH." >&2 ;;
      wsl)   echo "  Ensure clip.exe is available, or install xclip." >&2 ;;
      linux)
             # Detect display server to recommend the right tool
             if [[ "${XDG_SESSION_TYPE:-}" == "wayland" ]] || [[ -n "${WAYLAND_DISPLAY:-}" ]]; then
               echo "  Wayland detected. Install wl-clipboard:" >&2
               echo "    Ubuntu/Debian: sudo apt install wl-clipboard" >&2
               echo "    Fedora/RHEL:   sudo dnf install wl-clipboard" >&2
               echo "    Arch:          sudo pacman -S wl-clipboard" >&2
             else
               echo "  X11 detected. Install xclip:" >&2
               echo "    Ubuntu/Debian: sudo apt install xclip" >&2
               echo "    Fedora/RHEL:   sudo dnf install xclip" >&2
               echo "    Arch:          sudo pacman -S xclip" >&2
             fi ;;
    esac
    exit 1
  fi
fi

# 15) PHASE 3: EXECUTION
TMPFILE="$(mktemp)"

awk -v warn="$CLR_WARN" -v reset="$RESET" '
  {
    f = "./" $0
    r = (getline line < f)
    if (r < 0) {
      printf "%sWarning: Cannot read file '\''%s'\''. Skipping.%s\n", warn, f, reset > "/dev/stderr"
      next
    }
    print "# File: " $0
    if (r > 0) {
      print line
      while ((getline line < f) > 0) print line
    }
    close(f)
    print ""
  }
' "$LISTFILE" > "$TMPFILE"

# Use eval to handle multi-word clipboard commands (e.g., "xclip -selection clipboard")
# This is safe because CLIPBOARD_CMD is set internally, not from user input
if [[ "$USE_CLIPBOARD" == true ]]; then
  if ! eval "$CLIPBOARD_CMD" < "$TMPFILE" 2>/dev/null; then
    printf "\n${CLR_ERROR}✗ Clipboard copy failed!${RESET}\n" >&2
    printf "${DIM}The clipboard tool '${CLIPBOARD_CMD%% *}' could not copy the content.${RESET}\n" >&2
    
    # Provide platform-specific guidance
    case "$OS_TYPE" in
      linux)
        if [[ "${XDG_SESSION_TYPE:-}" == "wayland" ]] || [[ -n "${WAYLAND_DISPLAY:-}" ]]; then
          printf "${CLR_WARN}You appear to be on Wayland. Install wl-clipboard:${RESET}\n" >&2
          printf "  sudo apt install wl-clipboard  ${DIM}# Ubuntu/Debian${RESET}\n" >&2
        else
          printf "${CLR_WARN}Try installing xclip:${RESET}\n" >&2
          printf "  sudo apt install xclip  ${DIM}# Ubuntu/Debian${RESET}\n" >&2
        fi
        ;;
    esac
    
    printf "\n${DIM}Alternatively, use --print to output to terminal:${RESET}\n" >&2
    printf "  catclip --print > output.txt\n" >&2
    exit 1
  fi
  printf "\n${CLR_SUCCESS}✔${RESET} ${BOLD}Copied to clipboard!${RESET}\n" >&2
fi

if [[ "$PRINT_CONTENT" == true ]]; then
  cat "$TMPFILE"
fi
